#!/command/with-contenv bash
#shellcheck shell=bash disable=SC1091,SC2154,SC2015

# redirect stderr to stdout so it's picked up in the docker logs
source /scripts/common
shopt -s nullglob

[[ "$LOGLEVEL" != "ERROR" ]] && "${s6wrap[@]}" echo "Socket30003 started as an s6 service" || true

# -----------------------------------------------------------------------------------
# Copyright 2020-2025 Ramon F. Kolb - licensed under the terms and conditions
# of GPLv3. The terms and conditions of this license are included with the Github
# distribution of this package, and are also available here:
# https://github.com/sdr-enthusiasts/planefence4docker/
#
# The package contains parts of, and modifications or derivatives to the following:
# Dump1090.Socket30003 by Ted Sluis: https://github.com/tedsluis/dump1090.socket30003
# These packages may incorporate other software and license terms.
# -----------------------------------------------------------------------------------
#
# Make sure the /run directory exists
mkdir -p /run/socket30003
#
# Load parameters from the config file:
if [[ -f /usr/share/planefence/persist/planefence.config ]]; then
	set -o allexport
	source /usr/share/planefence/persist/planefence.config
	set +o allexport
fi

PF_SOCK30003PORT="${PF_SOCK30003PORT:-30003}"

# If things went wrong then simply sleep forever.
# No need to notify -- .../run/planefence is doing the same thing and is
# screaming all over the logs by now.
if [[ -z "$FEEDER_LAT" || "$FEEDER_LAT" == "90.12345" ]]; then
	sleep infinity
fi

# Make sure that $PF_SOCK30003HOST is defined
if [[ -z "$PF_SOCK30003HOST" ]]; then
	"${s6wrap[@]}" echo "\$PF_SOCK30003HOST is not set in the .env or docker-compose.yml file. Cannot run! Please update and restart the container."
	stop_service
fi

# LOOPTIME is used to delay a restart after socket30003 exits for any reason, as not to
# spam the system with restarts:
LOOPTIME=15
#
# RESTARTTIME - time between socket30003/cleanup cycles
RESTARTTIME=1h
# MAXLOGTIME - only keep log lines younger than this in socket30003 logs
MAXLOGTIME="1 hour"
#
# set params in socket30003.conf
sed -i 's/\(^\s*latitude=\).*/\1'"$FEEDER_LAT"'/' /usr/share/socket30003/socket30003.cfg
sed -i 's/\(^\s*longitude=\).*/\1'"$FEEDER_LONG"'/' /usr/share/socket30003/socket30003.cfg
sed -i 's|\(^\s*PEER_HOST=\).*|\1'"$PF_SOCK30003HOST"'|' /usr/share/socket30003/socket30003.cfg

sed -i 's/\(^\s*distanceunit=\).*/\1'"${PF_DISTUNIT:-nauticalmile}"'/' /usr/share/socket30003/socket30003.cfg
sed -i 's/\(^\s*altitudeunit=\).*/\1'"${PF_ALTUNIT:-feet}"'/' /usr/share/socket30003/socket30003.cfg
sed -i 's/\(^\s*speedunit=\).*/\1'"${PF_SPEEDUNIT:-knotph}"'/' /usr/share/socket30003/socket30003.cfg
sed -i 's|\(^\s*PEER_PORT=\).*|\1'"$PF_SOCK30003PORT"'|' /usr/share/socket30003/socket30003.cfg

# -----------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# Now start dump1090.socket30003 in a loop that restarts it $LOOPTIME seconds after it exits or crashes:
[[ "$LOGLEVEL" != "ERROR" ]] && "${s6wrap[@]}" echo "socket30003 starting its initial run now" || true
while true; do
	if ! timeout --preserve-status 3 netcat -z "$PF_SOCK30003HOST" "$PF_SOCK30003PORT" >/dev/null 2>&1; then
		"${s6wrap[@]}" echo "We cannot reach \"$PF_SOCK30003HOST\" on port $PF_SOCK30003PORT."
		"${s6wrap[@]}" echo "If this error keeps on repeating, please make sure that"
		"${s6wrap[@]}" echo "readsb/dump1090[-fa]/ultrafeeder is running and producing SBS data on port $PF_SOCK30003PORT!"
	else
		# clean up logs
		for f in /run/socket30003/*.txt; do
			tmpfile="$(mktemp -p /run/socket30003)"
			
			norm="${MAXLOGTIME:-3 hours}"; [[ $norm =~ ^[0-9]+$ ]] && norm=${norm}s
			cutD=$(date +%Y/%m/%d -d "-$norm")
			cutT=$(date +%H:%M:%S -d "-$norm")

			awk -F, -v cutD="$cutD" -v cutT="$cutT" '
				length($5)==10 && length($6)>=8 {
					t8 = substr($6,1,8)
					if ($5 > cutD || ($5 == cutD && t8 > cutT)) print
				}
			' "$f" > "$tmpfile"
			mv -f "$tmpfile" "$f"
		done

		"${s6wrap[@]}" echo "socket30003 starting up."
		touch /run/socket30003.up
		timeout "$RESTARTTIME" /usr/share/socket30003/socket30003.pl &>/dev/null || true
		exitcode="$?"
		rm -f /run/socket30003.up
		if (( exitcode != 124 )); then
			"${s6wrap[@]}" echo "/usr/share/socket30003/socket30003.pl exited with error code $exitcode. Restarting in $LOOPTIME"
			sleep $LOOPTIME & wait 
		fi

	fi
done
