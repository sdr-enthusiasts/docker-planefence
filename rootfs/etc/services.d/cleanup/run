#!/usr/bin/with-contenv bash
#shellcheck shell=bash

# redirect stderr to stdout so it's picked up in the docker logs
exec 2>&1
# all errors will show a line number and the command used to produce the error
SCRIPT_PATH="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 ; pwd)/$(basename "$0")"
trap 'echo -e "[ERROR] $SCRIPT_PATH in line $LINENO when executing: $BASH_COMMAND"' ERR

APPNAME="$(hostname)/cleanup"

[[ "$LOGLEVEL" != "ERROR" ]] && echo "[$APPNAME][$(date)] Cleanup started as an s6 service" || true

# -----------------------------------------------------------------------------------
# Copyright 2020, 2021 Ramon F. Kolb - licensed under the terms and conditions
# of GPLv3. The terms and conditions of this license are included with the Github
# distribution of this package, and are also available here:
# https://github.com/kx1t/docker-planefence
#
# -----------------------------------------------------------------------------------
# Feel free to make changes to the variables between these two lines. However, it is
# STRONGLY RECOMMENDED to RTFM! See README.md for explanation of what these do.
#
# LOOPTIME is the time between two runs cleanup. In our case, every 3 hours.
LOOPTIME="3h"
#
# OLDERTHAN indicates which age files can be deleted. This is in DAYS.
# It specifically applies to files in the HTML directory.
# If $PF_DELETEAFTER is set to "0" then we never delete.
# Note - files in /tmp will get deleted if they are older than 2 days.
PF_DELETEAFTER=$(grep "^PF_DELETEAFTER" /usr/share/planefence/persist/planefence.config 2>/dev/null| awk -F "=" '{ print $2 }')
[[ "x$PF_DELETEAFTER" == "x" ]] && OLDERTHAN=14 || OLDERTHAN=$PF_DELETEAFTER

PF_CHECKREMOTEDB=$(grep "^PF_CHECKREMOTEDB" /usr/share/planefence/persist/planefence.config 2>/dev/null| awk -F "=" '{ print $2 }')

#
# MAXLOGLINES contains the max number of lines that we will keep in /tmp/planefence.log
MAXLOGLINES=500
#
# MAXLOGTIME contains the max number of seconds that we will keep in any of the socket30003 logs
MAXLOGTIME=10800    # 10800 secs = 3 hours

# this function cleans out stuff. Make additions to it as needed.
CLEANUP ()
{
  if (( OLDERTHAN > 0 ))
  then
    [[ "$LOGLEVEL" != "ERROR" ]] && echo "[$APPNAME][$(date)] Cleaning up web files older than $OLDERTHAN days" || true
    [[ "$LOGLEVEL" != "ERROR" ]] && echo "[$APPNAME][$(date)] Cleaning up logs and tmp files older than 1 day" || true
    [[ "$LOGLEVEL" != "ERROR" ]] && echo "[$APPNAME][$(date)] Reducing planefence and noise2capt logs to $MAXLOGLINES lines (if needed)" || true

    #these are temp actions to facilitate the transition to the new directory structure:
    mkdir -p /usr/share/planefence/persist/.internal
    mv -f /usr/share/planefence/persist/*.tmp /usr/share/planefence/persist/.internal 2>/dev/null
    mv -f /usr/share/planefence/persist/*.log /usr/share/planefence/persist/.internal 2>/dev/null
    mv -f /usr/share/planefence/persist/planeownerscache.txt /usr/share/planefence/persist/.internal 2>/dev/null

    touch -t $(date -d "yesterday 00:00:00" +%Y%m%d%H%M) /tmp/timestamp
    find /usr/share/planefence/html/plane*{.html,.js,.csv} -mtime +$OLDERTHAN -delete 2>/dev/null
    find /usr/share/planefence/html/noise*.png -mtime +$OLDERTHAN -delete 2>/dev/null
    rm -f /run/socket30003/*.log
    find /run/socket30003/*.txt -type f ! -newer /tmp/timestamp -delete 2>/dev/null
    find /usr/share/planefence/persist/.internal/*.tmp -type f ! -newer /tmp/timestamp -delete 2>/dev/null
    find /usr/share/planefence/persist/.internal/*.log -type f ! -newer /tmp/timestamp -delete 2>/dev/null
    find /usr/share/planefence/persist/.internal/dump1090-pf-*.tmp -type f ! -newer /tmp/timestamp -delete 2>/dev/null
    rm -f /tmp/heatmap-*.log
    find /tmp -mindepth 1 -type f ! -newer /tmp/timestamp -delete 2>/dev/null
    rm -f /tmp/timestamp
    tmpfile=$(mktemp)
    shopt -s nullglob && for f in /run/socket30003/*.txt
    do
        [[ "$f" == "" ]] && continue || true
        fdate=${f: -10:6}   # get the date component from the file name

        # remove anything older than yesterday:
        (( fdate < $(date -d yesterday +%y%m%d) )) && rm -v -f $f && continue

        if [[ "$fdate" == "$(date -d yesterday +%y%m%d)" ]] && (( $(date -d "1970-01-01 $(date +%T) +0:00" +%s) > MAXLOGTIME ))
        then
            # If we're longer than MAXLOGTIME into today, then also remove yesterday's file
            rm -v -f $f
        elif [[ "$fdate" == "$(date -d yesterday +%y%m%d)" ]]
        then
            # We're less than MAXLOGTIME into today, so prune yesterday's file
            TIMELIMIT=$(date -d "@$(( $(date +%s) - MAXLOGTIME))" +%T |awk -F ":" '{print 3600*$1+60*$2+$3}')
            awk -F "," -v L=$TIMELIMIT '{split($6,time,":"); x=3600*time[1]+60*time[2]+time[3]; if (x>L) print;}' $f > $tmpfile
            [[ "$(wc -l < $tmpfile)" -gt 0 ]] && mv -f $tmpfile $f || rm -f $tmpfile $f
        fi

        # reverting this out for now. Socket30003 doesn't like it if we delete or prune the file underneith an active deployment.

        # also prune today's file
        if [[ "$fdate" == "$(date +%y%m%d)" ]]
        then
            TIMELIMIT=$(date -d "@$(( $(date +%s) - MAXLOGTIME))" +%T |awk -F ":" '{print 3600*$1+60*$2+$3}')
            awk -F "," -v L=$TIMELIMIT '{split($6,time,":"); x=3600*time[1]+60*time[2]+time[3]; if (x>L) print;}' $f > $tmpfile
            if [[ "$(wc -l < $tmpfile)" -gt 0 ]]
            then
                mv -f $tmpfile $f
            else
                # restart Socket30003 to ensure that things run smoothly:
                touch /tmp/socket-cleanup   # this flags the socket30003 runfile not to complain about the exit and restart immediately
                killall /usr/bin/perl && rm -f $tmpfile $f
            fi
        fi

    done


    if [[ -f /tmp/planefence.log ]]
    then
      tail -n $MAXLOGLINES /tmp/planefence.log >/tmp/planefence.log.tmp 2>/dev/null
      mv -f /tmp/planefence.log.tmp /tmp/planefence.log 2>/dev/null
    fi
    if [[ -f /tmp/noise2fence.log ]]
    then
      tail -n $MAXLOGLINES /tmp/noise2fence.log >/tmp/noise2fence.log.tmp 2>/dev/null
      mv -f /tmp/noise2fence.log.tmp /tmp/noise2fence.log 2>/dev/null
    fi
    if [[ -f /tmp/planetweet.log ]]
    then
      tail -n $MAXLOGLINES /tmp/planetweet.log >/tmp/planetweet.log.tmp 2>/dev/null
      mv -f /tmp/planetweet.log.tmp /tmp/planetweet.log 2>/dev/null
    fi
    if [[ -f /tmp/tweets.log ]]
    then
      tail -n $MAXLOGLINES /tmp/tweets.log >/tmp/tweets.log.tmp 2>/dev/null
      mv -f /tmp/tweets.log.tmp /tmp/tweets.log 2>/dev/null
    fi

    # remove empty lines from ignore file
    sed -i '/^$/d' /usr/share/planefence/persist/planefence-ignore.txt 2>/dev/null

  else
    [[ "$LOGLEVEL" != "ERROR" ]] && echo "[$APPNAME][$(date)] $LOOPTIME set to 0 - cleanup skipped" || true
  fi
  [[ "$tmpfile" != "" ]] && rm -f $tmpfile || true
}

# GET_ICAO_DB: Mictronics updates their ICAO-to-Tail database once a week.
# If the existing file is older than last Monday's (or if none exists), then get a new one
GET_ICAO_DB ()
{
    if (( $(date -r /run/planefence/icao2plane.txt +%s 2>/dev/null || echo 0) < $(date -d "next monday - 7 days" +%s) ))
    then
        [[ "$LOGLEVEL" != "ERROR" ]] && echo "[$APPNAME][$(date)] Retrieving ICAO to TAIL database from https://www.mictronics.de ... " || true
        # note - the curl won't fail, even if the file is not found because the PHP page doesn't return a 400 code but a regular result webpage
        curl -s -L -f -o /tmp/icao24plus.zip https://www.mictronics.de/aircraft-database/icao24plus.php
        if [[ "$?" != "0" ]]
        then
            echo "[$APPNAME][$(date)] Retrieving ICAO to TAIL database from https://www.mictronics.de FAILED!"
            return 1
        fi

        [[ "$LOGLEVEL" != "ERROR" ]] && echo "[$APPNAME][$(date)] unzipping ... " || true
        # unzipping *will* fail when the retrieved file is not a valid ZIP file
        unzip -qq -d /tmp -o /tmp/icao24plus.zip 2>/dev/null
        if [[ "$?" != "0" ]]
        then
            echo "[$APPNAME][$(date)] Unzipping ICAO to TAIL database from https://www.mictronics.de FAILED!"
            return 1
        fi

        rm -f /tmp/icao24plus.zip
        # now convert the text based file into a CSV file
        [[ "$LOGLEVEL" != "ERROR" ]] && echo "[$APPNAME][$(date)] converting ... " || true
        sed -i 's|\([0-9A-F]\{6\}\)\s*\([A-Z0-9\-]*\)\s*\([A-Z0-9]*\)\s*\(.*\)|\1,\2,\3,\4|g' /tmp/icao24plus.txt
        if [[ "$?" != "0" ]]
        then
            echo "[$APPNAME][$(date)] Converting ICAO to TAIL database from https://www.mictronics.de FAILED!"
            return 1
        fi

        mv -f /tmp/icao24plus.txt /run/planefence/icao2plane.txt
        [[ "$LOGLEVEL" != "ERROR" ]] && echo "[$APPNAME][$(date)] done!" || true
    else
        [[ "$LOGLEVEL" != "ERROR" ]] && echo "[$APPNAME][$(date)] ICAO to TAIL database is up to date" || true
    fi
}
#
# GET_AIRLINE_DB retrieves the list of airline names from 2 sources:
# - https://raw.githubusercontent.com/kx1t/planefence-airlinecodes/main/airlinecodes.txt
# - https://raw.githubusercontent.com/jbroutier/whatisflying-db/master/data/airlines.csv
# ad merges these with the preloaded list.
GET_AIRLINE_DB ()
{
    [[ "$LOGLEVEL" != "ERROR" ]] && echo "[$APPNAME][$(date)] Updating airline names database..." || true
    rm -f /tmp/airlinecodes.txt /tmp/airlines.csv /tmp/airlinecodes.txt.tmp
    curl --compressed -s -L -f https://raw.githubusercontent.com/kx1t/planefence-airlinecodes/main/airlinecodes.txt -o /tmp/airlinecodes.txt && [[ "$LOGLEVEL" != "ERROR" ]] && echo "[$APPNAME][$(date)] Got kx1t/planefence-airlinecodes" || true
    curl --compressed -s -L -f https://raw.githubusercontent.com/jbroutier/whatisflying-db/master/data/airlines.csv -o /tmp/airlines.csv && [[ "$LOGLEVEL" != "ERROR" ]] && echo "[$APPNAME][$(date)] Got jbroutier/whatisflying-db" || true

    #convert JBroutier's DB into our format:
    if [[ -f /tmp/airlines.csv ]]
    then
        IFS="," read -ra header < /tmp/airlines.csv
        # get the field number for the icao and airline name fields
        for ((i=0; i<${#header[@]}; i++)); do if [[ "${header[$i]}" == "icao_code" ]]; then icao=$i; break; fi; done
        for ((i=0; i<${#header[@]}; i++)); do if [[ "${header[$i]}" == "name" ]]; then name=$i; break; fi; done
        for ((i=0; i<${#header[@]}; i++)); do if [[ "${header[$i]}" == "country" ]]; then country=$i; break; fi; done
        for ((i=0; i<${#header[@]}; i++)); do if [[ "${header[$i]}" == "callsign" ]]; then callsign=$i; break; fi; done
	#echo "header has ${#header[@]} elements and contains:"
	#echo ${header[@]}
	#echo "icao=$icao name=$name country=$country callsign=$callsign"
        if [[ ! -z "$icao" ]] && [[ ! -z "$name" ]] && [[ ! -z "$country" ]] && [[ ! -z "$callsign" ]]
        then
            tail -n +2 /tmp/airlines.csv | awk -F "," -v icao=$(( icao + 1 )) -v name=$(( name + 1 )) -v country=$(( country + 1 )) -v callsign=$(( callsign + 1 )) '{print $icao "," $name "," $callsign "," $country}' >> /tmp/airlinecodes.txt.tmp
            [[ -f /tmp/airlinecodes.txt ]] && cat /tmp/airlinecodes.txt /tmp/airlinecodes.txt.tmp > /tmp/airlinecodes.txt.tmp2 || cat /tmp/airlinecodes.txt.tmp > /tmp/airlinecodes.txt.tmp2
	        [[ "$LOGLEVEL" != "ERROR" ]] && echo "[$APPNAME][$(date)] Removed $(awk -F',' 'seen[$1]++' /tmp/airlinecodes.txt.tmp2 |wc -l) overlapping entries, left $(awk -F',' '!seen[$1]++' /tmp/airlinecodes.txt.tmp2 |wc -l) entries in place" || true
            awk -F',' '!seen[$1]++' /tmp/airlinecodes.txt.tmp2 >/tmp/airlinecodes.txt
        fi
    fi
    mv -f /tmp/airlinecodes.txt /usr/share/planefence/persist
    rm -f /tmp/airlines.csv /tmp/airlinecodes.txt.tmp /tmp/airlinecodes.txt.tmp2
    [[ "$LOGLEVEL" != "ERROR" ]] && echo "[$APPNAME][$(date)] Airlinecodes database update complete" || true
}

#Now loop forevah:
while true
do
  [[ "$LOGLEVEL" != "ERROR" ]] && echo "[$APPNAME][$(date)] Performing a cleanup run..." || true
  CLEANUP
  GET_ICAO_DB
  GET_AIRLINE_DB
  [[ "$LOGLEVEL" != "ERROR" ]] && echo "[$APPNAME][$(date)] Cleanup done. Sleeping for $LOOPTIME" || true
  sleep $LOOPTIME
done
