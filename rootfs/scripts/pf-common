# shellcheck shell=bash disable=SC1091,SC2034,SC2154
# -----------------------------------------------------------------------------------
# Copyright 2025 Ramon F. Kolb, kx1t - licensed under the terms and conditions
# of GPLv3. The terms and conditions of this license are included with the Github
# distribution of this package, and are also available here:
# https://github.com/kx1t/docker-planefence/
#
# This package may incorporate other software and license terms.
# -----------------------------------------------------------------------------------
#
# Common functions for Planefence / Plane-Alert
# To be sourced in at the beginning of other bash scripts - not a stand-alone file

source /scripts/common

MAXWAITTIME=300   # max time we'll wait for the records lock to expire

declare -gA records

debug_print() {
    local currenttime
    if [[ -z "$execstarttime" ]]; then
      execstarttime="$(date +%s.%3N)"
      execlaststeptime="$execstarttime"
    fi
    currenttime="$(date +%s.%3N)"
    if chk_enabled "$DEBUG"; then 
      "${s6wrap[@]}" printf "[DEBUG] %s (%s secs, total time elapsed %s secs)\n" "$1" "$(bc -l <<< "$currenttime - $execlaststeptime")" "$(bc -l <<< "$currenttime - $execstarttime")" >&2
    fi
    execlaststeptime="$currenttime"
}

# shellcheck disable=SC2120
LOCK_RECORDS() {
    if [[ "${1,,}" != "ignore-lock" ]] && [[ -f "/tmp/.records.lock" ]]; then
    debug_print "Waiting for records.lock to become unlocked..."
    # wait until the lock is gone, or 120 seconds (whichever is shorter)
    while :; do
      starttime="$(date +%s)"
      sleep "0.${RANDOM: -3}s"
      if [[ ! -f "/tmp/.records.lock" ]] || (( $(date +%s) - starttime > MAXWAITTIME )); then break; fi
    done
  fi
  touch "/tmp/.records.lock"
  debug_print "Records locked by $0"
}

UNLOCK_RECORDS() {
  rm -f "/tmp/.records.lock"
  debug_print "Records unlocked by $0"
}

READ_RECORDS() {
  local TODAY="${TODAY:-$(date +%y%m%d)}"
  local RECORDSFILE="${RECORDSFILE:-$HTMLDIR/.planefence-records-${TODAY}}"

  if [[ ! -f "$RECORDSFILE" ]]; then 
    debug_print "RECORDSFILE (\"$RECORDSFILE\") not found - initializing"
    declare -gA records=()
    declare -gA heatmap=()
    declare -gA last_idx_for_icao=()
    declare -gA lastseen_for_icao=()
    records[maxindex]=-1
    return
  fi

  if [[ "${1,,}" != "ignore-lock" ]] && [[ -f "/tmp/.records.lock" ]]; then
  # wait until the lock is gone, or 120 seconds (whichever is shorter)
    debug_print "Waiting for records.lock to become unlocked..."
    starttime="$(date +%s)"
    while :; do
      sleep "0.${RANDOM: -3}s"
      if [[ ! -f "/tmp/.records.lock" ]] || (( $(date +%s) - starttime > MAXWAITTIME )); then break; fi
    done
    debug_print "Records.lock unlocked. Continuing..."
  fi
  debug_print "Records read by $0"
  # shellcheck disable=SC1090
  source "$RECORDSFILE"

}

WRITE_RECORDS() {

  local TODAY="${TODAY:-$(date +%y%m%d)}"
  local RECORDSFILE="${RECORDSFILE:-$HTMLDIR/.planefence-records-${TODAY}}"

  LOCK_RECORDS ignore-lock
  #declare -A records last_idx_for_icao lastseen_for_icao  # declare them just in case they don't exist yet
  { declare -p records
    declare -p heatmap
    declare -p last_idx_for_icao
    declare -p lastseen_for_icao; } > "$RECORDSFILE"
  sed -i 's/declare \(-.\{1\}\) /declare \1g /g' "$RECORDSFILE" # make sure the declare function includes "-g" for global
  debug_print "Records written by $0"
  UNLOCK_RECORDS
}

# Function to encode special characters for XML
xml_encode() {
    echo "$1" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g; s/"/\&quot;/g; s/'"'"'/\&apos;/g'
}

json_encode() {
  local s=${1-}
  case "$s" in
    (*[\"\\$'\n'$'\r'$'\t'$'\b'$'\f']*) ;; 
    (*) printf '%s' "$s"; return ;;
  esac

  # escape backslash and quote with sed, then map controls with tr
  printf '%s' "$s" | sed -u -e 's/\\/\\\\/g' -e 's/"/\\"/g' \
    | tr '\b\f\n\r\t' '\\b\\f\\n\\r\\t'
}

csv_encode() {
  local s
  s=$1

  # Quick safe-return for empty string
  if [[ -z "${s+set}" ]] || [[ "$s" = "" ]]; then
    printf '%s' "$s"
    return
  fi

  # Needs quoting if contains comma, double-quote, newline, CR, or leading/trailing space
  case "$s" in
    *[,$'\n'$'\r'"\""]* ) ;;
    [[:space:]]*|*'[[:space:]]' ) ;;  # fall through to quoting
    * ) printf '%s' "$s"; return ;;
  esac

  # Double internal quotes per RFC 4180
  s=${s//\"/\"\"}
  printf '"%s"' "$s"
}

template_replace() {
  local token=$1 repl=$2 template=$3 prefix
  [[ -z ${token+x} || -z ${repl+x} || -z ${template+x} ]] && { p
rintf 'Usage: template_replace token replacement template\n' >&2
; return 1; }
  [[ $token == "" ]] && { printf '%s' "$template"; return 0; }
  [[ $template != *"$token"* ]] && { printf '%s' "$template"; re
turn 0; }

  local tmp
  tmp=$(mktemp) || { printf 'mktemp failed\n' >&2; return 1; }
  {
    while [[ $template == *"$token"* ]]; do
      prefix=${template%%"$token"*}
      printf '%s%s' "$prefix" "$repl"
      template=${template#*"$token"}
    done
    printf '%s' "$template"
  } >"$tmp"
  cat "$tmp"
  rm -f -- "$tmp"
}


# template_replace() {
#   # Usage: template_replace search_string replace_string template_string
#   local pat="$1" repl="$2" template="$3"
#   [[ -z ${template+x} ]] && { printf 'Usage: template_replace search_string replace_string template_string\n' >&2; return 1; }

#   # Escape glob metacharacters in pattern so match is literal.
#   # Your pattern chars are [A-Za-z0-9-!#_]*, so only '-' and '!' can be globby in some contexts,
#   # but we escape the full set defensively.
#   local esc_pat=$pat
#   esc_pat=${esc_pat//\\/\\\\}   # backslash first
#   esc_pat=${esc_pat//\*/\\*}
#   esc_pat=${esc_pat//\?/\\?}
#   esc_pat=${esc_pat//\[/\\[}

#   # Disable globbing; prevent word-splitting; keep repl literal (incl. & and $).
#   local oldopts=$-
#   set -f
#   local IFS=
#   # shellcheck disable=SC2295
#   template=${template//"$esc_pat"/$repl}
#   [[ $oldopts == *f* ]] || set +f

#   printf '%s' "$template"
# }

DISTUNIT="mi"
ALTUNIT="ft"
TO_METER=1609
if [[ -f "${SOCKETCONFIG:-/usr/share/socket30003/socket30003.cfg}" ]]; then
	case "$(grep "^distanceunit=" "${SOCKETCONFIG:-/usr/share/socket30003/socket30003.cfg}" |sed "s/distanceunit=//g")" in
		nauticalmile)
		DISTUNIT="nm"
    TO_METER=1852
		;;
		kilometer)
		DISTUNIT="km"
		TO_METER=1000
		;;
		mile)
		DISTUNIT="mi"
		TO_METER=1609
		;;
		meter)
		DISTUNIT="m"
		TO_METER=1
	esac
	case "$(grep "^altitudeunit=" "${SOCKETCONFIG:-/usr/share/socket30003/socket30003.cfg}" |sed "s/altitudeunit=//g")" in
		feet)
		ALTUNIT="ft"
		;;
		meter)
		ALTUNIT="m"
	esac
fi
