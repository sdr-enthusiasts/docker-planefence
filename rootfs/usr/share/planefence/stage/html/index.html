<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Planefence</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/datatables.net-dt/css/jquery.dataTables.min.css">
  <!-- 1) CSS: row dim + small updater + dark zebra fix -->
  <style>

    /* Dim entire row while incomplete */
    tr.row-incomplete { color: var(--row-incomplete); }
    tr.row-incomplete a { color: inherit; }
    tr.row-incomplete .muted { color: inherit; opacity: .9; }

    /* Small “still updating” */
    .still-updating { font-size: 0.85em; }

    /* Override DataTables zebra to adapt to theme */
    table.dataTable.stripe tbody tr.odd,
    table.dataTable.display tbody tr.odd {
      background-color: var(--table-stripe);
    }
    /* Ensure even rows use base bg in both themes */
    table.dataTable tbody tr.even { background-color: var(--bg); }

    :root {
      color-scheme: light dark;
      /* height reserved for the top page header; table thead will stick beneath this */
      --header-height: 3.5rem;
      --bg: #ffffff;
      --fg: #111111;
      --muted: #666;
      --soft: #f5f5f5;
      --accent: #0b5fff;
      --danger-bg: #fff3f3;
      --danger-fg: #a40000;
      --row-incomplete: #6b6b6b;
      --chip-bg: #eee;
      --chip-fg: #222;
      --link: #0b5fff;
      --link-visited: #5a32a3;
      --table-stripe: #fafafa;
    }
    html.dark {
      --bg: #0f1115;
      --fg: #e6e6e6;
      --muted: #9aa0a6;
      --soft: #1a1d23;
      --accent: #6ca0ff;
      --danger-bg: #2a1212;
      --danger-fg: #ff8a8a;
      --row-incomplete: #9aa0a6;
      --chip-bg: #1f2430;
      --chip-fg: #e6e6e6;
      --link: #8fb1ff;
      --link-visited: #c6a6ff;
      --table-stripe: #151922;
    }

    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", sans-serif;
      background: var(--bg); color: var(--fg);
      line-height: 1.45;
    }
  header, footer { padding: .75rem 1rem; background: var(--soft); display: flex; align-items: center; gap: .75rem; }
  /* Keep header visible while scrolling */
  header { position: sticky; top: 0; z-index: 50; }
    header h1 { font-size: 1.1rem; margin: 0; font-weight: 600; }
    header .spacer { flex: 1; }
    button, .btn {
      background: transparent; border: 1px solid var(--muted); color: var(--fg); padding: .35rem .6rem; border-radius: .5rem; cursor: pointer;
    }
    /* Force the theme toggle to inherit and display the foreground color explicitly */
    #themeToggle { color: var(--fg) !important; }
    #themeToggle svg { color: currentColor; }
    /* Ensure theme toggle SVG is visible in both themes */
    #themeToggle svg { width: 1.1em; height: 1.1em; display: inline-block; vertical-align: middle; }
    button:hover { border-color: var(--fg); }
    a { color: var(--link); text-decoration: none; }
    a:visited { color: var(--link-visited); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .muted { color: var(--muted); }
    .status { margin-left: .5rem; }

    table.dataTable tbody tr:nth-child(odd) { background: var(--table-stripe); }
    table.dataTable thead th { white-space: nowrap; }
  /* Left-align all table headers for better readability */
  table.dataTable thead th, table#t thead th { text-align: left !important; }
  /* Removed Spectro column; kept layout flexible */
    /* Keep the table header visible while scrolling; it will sit just below the page header */
    table.dataTable thead th {
      position: sticky;
      top: var(--header-height);
      z-index: 40;
      background: var(--soft);
    }
    /* Give the first data row extra padding so it clears the sticky header */
    table.dataTable tbody tr:first-of-type > * {
      padding-top: 1.5rem;
    }
    th, td { vertical-align: middle; }
  img.thumb { height: 56px; width: 56px; object-fit: cover; border-radius: .25rem; background: #0001; }
  /* Silhouette thumbnails: keep width same as thumb, preserve aspect ratio */
  img.thumb.thumb-sil { width: 56px; height: auto; max-height: 56px; object-fit: contain; }
    .angle-img { height: 1em; vertical-align: -0.2em; margin-left: .25rem; }
  /* Position cell: give a little gap between coords and angle line */
  td.position-cell div { line-height: 1.2; }
  td.position-cell div + div { margin-top: 0.15rem; }
  /* Ensure angle image aligns center with the angle text */
  .angle-img { vertical-align: middle; height: 1em; margin-left: .35rem; }
    .chip { display: inline-flex; align-items: center; gap: .35rem; background: var(--chip-bg); color: var(--chip-fg); padding: .1rem .4rem; border-radius: .5rem; font-size: .85em; }
  .dot { display:none; }
    .danger { background: var(--danger-bg); color: var(--danger-fg); font-weight: 600; padding: 0 .25em; border-radius: .25em; }
  /* small SVG icons inside chips — make slightly larger for visibility */
  .chip svg { height: 1.25em; width: 1.25em; vertical-align: -0.15em; }
  .chip.muted { opacity: 0.8; }
  .badge-icon { height: 1.25em; width: 1.25em; object-fit: contain; vertical-align: -0.15em; }
  /* Slightly increase chip padding for better tap targets and add spacing between chips */
  .chip { padding: 0.15rem 0.5rem; }
  .chip + .chip { margin-left: 0.35rem; }
  /* Tooltip hint for non-link notifications: underline only the label, not the chip outline */
  .chip.has-tooltip { cursor: help; }
  .chip.has-tooltip .label { border-bottom: 1px dotted currentColor; }
  /* Keep notifier icons at or below line height and align nicely */
  .ico { height: 1em; width: 1em; vertical-align: text-bottom; }
  .chip .ico { margin-right: .3rem; }
  /* For notifier links that are not chips (Notifications column), add spacing */
  td:nth-child(11) a .ico { margin-right: .3rem; }
  /* Center the empty state message nicely */
  td.dataTables_empty { height: 40vh; vertical-align: middle !important; text-align: center !important; color: var(--muted); }
  /* Improve spacing for notification chips inside the Notifications cell */
  td:nth-child(10) a.chip { margin-right: .25rem; }

  /* Visually hidden text for accessibility */
  .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 1px, 1px); border: 0; }
  /* In dark mode, invert bitmap badges so dark lines become light */
  html.dark .badge-icon { filter: invert(1) brightness(2) contrast(1.2); }

  /* Chips (small badges) should use the chip background color in dark mode */
  html.dark .chip { background: var(--chip-bg); color: var(--chip-fg); }

  /* Modal preview for spectro images */
  .pf-modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.7); align-items: center; justify-content: center; z-index: 9999; }
  .pf-modal.open { display: flex; }
  .pf-modal .box { max-width: 90%; max-height: 90%; border-radius: .5rem; overflow: hidden; box-shadow: 0 8px 32px rgba(0,0,0,.6); }
  .pf-modal img { display: block; max-width: 100%; max-height: 100%; }

    .seen-incomplete { color: var(--row-incomplete); }

    .nowrap { white-space: nowrap; }
  /* Prevent Seen column from collapsing too narrow */
  /* DataTables places columns in the table header; target the third th (index starts at 1) */
  /* Keep Seen column readable but compact: single-line with ellipsis if too long */
  table.dataTable thead th:nth-child(3) { min-width: 8rem; max-width: 12rem; }
  table.dataTable tbody td:nth-child(3) { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  /* Highlight freshly-added rows briefly (soft fade-out) */
  .pf-new-row { animation: pf-fade 2.2s ease-out; background-color: rgba(108,169,255,0.18); }
  @keyframes pf-fade { 0% { background-color: rgba(108,169,255,0.28); } 100% { background-color: transparent; } }
  /* Ensure DataTables respects theme colors in dark mode and doesn't leave
    white cells/stripes. Use !important where DataTables default CSS is stronger. */
  table.dataTable { background: transparent; }
  table.dataTable tbody td, table.dataTable tbody tr { background: transparent; }
  /* Regular stripe rules (light and dark) */
  table.dataTable.stripe tbody tr.odd,
  table.dataTable.display tbody tr.odd { background-color: var(--table-stripe) !important; }
  table.dataTable tbody tr.even { background-color: var(--bg) !important; }
  /* Dark-mode specific enforcement to override DataTables' defaults */
  html.dark table.dataTable.stripe tbody tr.odd,
  html.dark table.dataTable.display tbody tr.odd { background-color: var(--table-stripe) !important; }
  html.dark table.dataTable tbody tr.even { background-color: var(--bg) !important; }
  /* Ensure individual cells (including the index cell span) don't show white */
  html.dark table.dataTable tbody td, html.dark table.dataTable tbody td * { background: transparent !important; color: var(--fg) !important; }
  /* DataTables sometimes wraps table body for scrolling; ensure those cells are covered */
  html.dark .dataTables_scrollBody table tbody tr td { background: transparent !important; }

  /* New-updates button default style (light mode) */
  #newUpdates { background: var(--chip-bg); color: var(--chip-fg); border-color: var(--muted); }
  /* Dark-mode adjustments for banner/button */
  html.dark #newUpdates { background: rgba(108,169,255,0.08); color: var(--fg); border-color: rgba(255,255,255,0.06); }

  /* Make the new-row highlight slightly different in dark mode */
  html.dark .pf-new-row { background-color: rgba(108,169,255,0.12) !important; }

  /* Row hover: ensure hover color is theme-aware (not white in dark mode) */
  /* Light mode hover: subtle darker tint */
  table.dataTable tbody tr:hover { background-color: rgba(0,0,0,0.03) !important; }
  table.dataTable tbody tr:hover td, table.dataTable tbody tr:hover td * { background: transparent !important; }
  /* Dark mode hover: subtle light tint */
  html.dark table.dataTable tbody tr:hover { background-color: rgba(255,255,255,0.03) !important; }
  html.dark table.dataTable tbody tr:hover td, html.dark table.dataTable tbody tr:hover td * { background: transparent !important; }

  /* Toggle switch for theme */
  .switch { position: relative; display: inline-block; width: 44px; height: 24px; }
  .switch input { opacity: 0; width: 0; height: 0; }
  .switch .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background: var(--muted); transition: .2s ease; border-radius: 999px; }
  .switch .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; top: 3px; background: var(--bg); transition: .2s ease; border-radius: 50%; box-shadow: 0 1px 2px rgba(0,0,0,0.25); }
  .switch input:checked + .slider { background: var(--accent); }
  .switch input:checked + .slider:before { transform: translateX(20px); }
  .theme-toggle { display: flex; align-items: center; gap: .4rem; }
  .theme-toggle .theme-ico { display: inline-flex; color: var(--muted); opacity: .8; transition: color .2s ease, opacity .2s ease; font-size: 1.15rem; line-height: 1; }
  html.dark .theme-toggle .theme-ico.moon,
  html:not(.dark) .theme-toggle .theme-ico.sun { color: var(--accent); opacity: 1; }
  .header-divider { width: 1px; height: 1.5rem; background: var(--muted); opacity: .5; margin: 0 .75rem; }
  html.dark .header-divider { opacity: .35; }
  .mode-toggle { display: flex; align-items: center; gap: .35rem; font-size: .85rem; }
  .mode-toggle .mode-label { font-weight: 600; }
  .switch.switch-mode { width: 56px; height: 26px; }
  .switch.switch-mode .slider:before { width: 20px; height: 20px; top: 3px; }
  .switch.switch-mode input:checked + .slider:before { transform: translateX(28px); }
  .pf-controls { display: flex; flex-wrap: wrap; align-items: center; justify-content: space-between; gap: 1rem; margin-bottom: .5rem; }
  .pf-controls .pf-left { display: flex; align-items: center; }
  .pf-controls .pf-right { display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; justify-content: flex-end; }
  .pf-controls .pf-right .dataTables_filter { margin: 0; }
  .pf-controls .pf-right .dataTables_filter label { display: flex; align-items: center; gap: .35rem; margin: 0; }
  .pf-controls .pf-right .dataTables_info { margin: 0; white-space: nowrap; }
  .pf-controls .pf-right .dataTables_paginate { margin: 0; }
  </style>
</head>
<body>
  <header>
    <h1>Planefence</h1>
    <span class="status mono" id="progress">Loading…</span>
  <span class="status mono" id="lastupdate" style="margin-left: .5rem"></span>
  <span class="status mono" id="nextupdate" style="margin-left: .75rem">Next update: --</span>
    <div class="spacer"></div>
    <div class="mode-toggle" role="group" aria-label="Choose data source">
      <span class="mode-label">Planefence</span>
      <label class="switch switch-mode" title="Toggle between Planefence and Plane-Alert data">
        <input id="dataModeToggle" type="checkbox" aria-label="Switch data source" />
        <span class="slider" aria-hidden="true"></span>
      </label>
      <span class="mode-label">Plane-Alert</span>
    </div>
    <div class="header-divider" aria-hidden="true"></div>
    <div class="theme-toggle">
      <span class="theme-ico sun" aria-hidden="true">&#9728;</span>
      <div class="theme-switch-wrap">
        <label class="switch" title="Toggle dark/light">
          <input id="themeToggle" type="checkbox" aria-label="Toggle theme" />
          <span class="slider" aria-hidden="true"></span>
        </label>
      </div>
      <span class="theme-ico moon" aria-hidden="true">&#9790;</span>
    </div>
  <button id="manualUpdate" title="Update now">Update</button>
  <button id="reload" title="Reload data">Reload</button>
  <button id="newUpdates" title="Show new updates" style="display:none; margin-left:.5rem;">New updates available</button>
  </header>

  <main style="padding: 0 1rem 1rem;">
    <div style="overflow:auto;">
      <table id="t" class="display compact stripe" style="width:100%;">
        <thead id="thead">
          <tr></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </main>

  <footer>
    <small class="muted">&copy; 2025 Ram&oacute;n F. Kolb, kx1t. All rights reserved. Code is licensable under the terms and conditions of GPLv3 - see <a href="https://github.com/kx1t/docker-planefence" target="_blank">Github repo</a>. <a href="https://github.com/sdr-enthusiasts/docker-planefence/blob/main/ATTRIBUTION.md" target="_blank">Attributions</a>. Version ##VERSION##</small>
  </footer>

  <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/datatables.net@2/js/dataTables.min.js"></script>

  <script>
  // -------- Config --------
  const cfg = {
    // Base URL where docroot images live (arrowXXX_day|night.png, thumbnails if hosted locally)
    // Ensure trailing slash. Change as needed, e.g., `${location.origin}/assets/`
    // mediaBase: location.origin + 'assets/',
    mediaBase: './assets/',
    // Temporary prefix to apply to noise/spectro/mp3 links (easy to change)
    // Set to empty string to disable. Useful when those files are served under a subpath like /noise/
    // noisePrefix: './noise/',
  noisePrefix: './',
  // Directory for aircraft silhouettes (configurable). Ensure trailing slash.
  silhouetteDir: './assets/silhouettes/',
  // Optional per-badge images (inlined as data URI so the page doesn't need external assets)
  // The UI will use CSS (html.dark .badge-icon) to invert/brighten bitmap/SVG badges in dark mode.
    noiseIcon: 'data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2216%22%20height%3D%2216%22%3E%3Ccircle%20cx%3D%228%22%20cy%3D%228%22%20r%3D%226%22%20fill%3D%22%230b5fff%22/%3E%3C/svg%3E',
    mp3Icon: 'data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2216%22%20height%3D%2216%22%3E%3Ccircle%20cx%3D%228%22%20cy%3D%228%22%20r%3D%226%22%20fill%3D%22%23ff8a00%22/%3E%3C/svg%3E',
    // Enable or disable the live stream reader and/or periodic polling. Set one or both to true as needed.
    enableStream: true,
    enablePoll: true,
    // Poll interval in seconds (used when enablePoll is true)
    pollIntervalSec: 60
  };

  const truthy = (v) => {
    if (v === true || v === 1) return true;
    if (typeof v === 'string') {
      const s = v.toLowerCase();
      return s === 'true' || s === '1' || s === 'yes';
    }
    return false;
  };

    // -------- Data mode (Planefence vs Plane-Alert) --------
    const DATA_MODE_KEY = 'pf-data-mode';
    const DATA_MODES = {
      PLANEFENCE: 'planefence',
      PLANE_ALERT: 'plane-alert'
    };
    function modeFromQuery(){
      try {
        const params = new URLSearchParams(window.location.search || '');
        const raw = params.get('mode');
        if (!raw) return null;
        const normalized = raw.trim().toLowerCase();
        if (!normalized) return null;
        if (normalized === 'pf' || normalized === DATA_MODES.PLANEFENCE) return DATA_MODES.PLANEFENCE;
        if (normalized === 'pa' || normalized === DATA_MODES.PLANE_ALERT || normalized === 'planealert') return DATA_MODES.PLANE_ALERT;
        return null;
      } catch (e) {
        return null;
      }
    }
    function currentDataMode(){
      try {
        const saved = localStorage.getItem(DATA_MODE_KEY);
        return saved === DATA_MODES.PLANE_ALERT ? DATA_MODES.PLANE_ALERT : DATA_MODES.PLANEFENCE;
      } catch (e) {
        return DATA_MODES.PLANEFENCE;
      }
    }
    const presetMode = modeFromQuery();
    if (presetMode) {
      try { localStorage.setItem(DATA_MODE_KEY, presetMode); } catch (e) { /* ignore */ }
    }
    let dataMode = presetMode || currentDataMode();
    function isPlaneAlertMode(){
      return dataMode === DATA_MODES.PLANE_ALERT;
    }
    function applyDataModeUI(){
      const toggle = document.getElementById('dataModeToggle');
      if (toggle) {
        try { toggle.checked = isPlaneAlertMode(); } catch (e) { /* ignore */ }
        const label = isPlaneAlertMode() ? 'Switch to Planefence data' : 'Switch to Plane-Alert data';
        toggle.setAttribute('aria-label', label);
      }
      const heading = document.querySelector('header h1');
      if (heading) heading.textContent = isPlaneAlertMode() ? 'Plane-Alert' : 'Planefence';
    }
    applyDataModeUI();
    let modeGeneration = 0;
    let streamAbortController = null;
    let pollIntervalHandle = null;
    function buildStreamUrl(mode){
      const base = './cgi/stream.sh';
      return mode === DATA_MODES.PLANE_ALERT ? `${base}?mode=plane-alert` : base;
    }
    function currentStreamUrl(){
      return buildStreamUrl(dataMode);
    }
    (function(){
      const toggle = document.getElementById('dataModeToggle');
      if (!toggle) return;
      toggle.addEventListener('change', ()=>{
        const newMode = toggle.checked ? DATA_MODES.PLANE_ALERT : DATA_MODES.PLANEFENCE;
        if (newMode === dataMode) return;
        try { localStorage.setItem(DATA_MODE_KEY, newMode); } catch (e) { /* ignore */ }
        dataMode = newMode;
        applyDataModeUI();
        restartDataPipelines();
      });
    })();

  // -------- Theme (dark/light) --------
  const THEME_KEY = 'pf-theme';
  function applyTheme(theme){
    const dark = theme === 'dark';
    document.documentElement.classList.toggle('dark', dark);
    const toggle = document.getElementById('themeToggle');
    if (toggle) {
      const label = dark ? 'Switch to light theme' : 'Switch to dark theme';
      toggle.setAttribute('aria-label', label);
      try { toggle.checked = dark; } catch(e) { /* ignore */ }
    }
    localStorage.setItem(THEME_KEY, theme);
    // After theme flip, update arrow images to day/night variants without full re-render
    try { updateAngleImagesForTheme(dark); } catch(e) { /* ignore */ }
  }
  function currentTheme(){
    const saved = localStorage.getItem(THEME_KEY);
    if (saved === 'dark' || saved === 'light') return saved;
    return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
  }
  applyTheme(currentTheme());
  // On initial apply, ensure arrow images reflect theme
  try { updateAngleImagesForTheme(document.documentElement.classList.contains('dark')); } catch(e){}
  (function(){
    const t = document.getElementById('themeToggle');
    if (!t) return;
    // Ensure initial checked reflects current theme
    try { t.checked = document.documentElement.classList.contains('dark'); } catch(e){}
    t.addEventListener('change', () => {
      const useDark = !!t.checked;
      applyTheme(useDark ? 'dark' : 'light');
      // No need to invalidate rows just to swap arrow icons; we directly update sources.
    });
  })();

  // -------- Helpers --------
  const prog = document.getElementById('progress');
  if (prog) prog.textContent = isPlaneAlertMode() ? 'Loading Plane-Alert…' : 'Loading…';
  const lastUpdateEl = document.getElementById('lastupdate');
  const nextUpdateEl = document.getElementById('nextupdate');
  const theadRow = document.querySelector('#thead tr');
  const reloadBtn = document.getElementById('reload');
  reloadBtn?.addEventListener('click', () => location.reload());
  const manualUpdateBtn = document.getElementById('manualUpdate');
  // global button reference (element created in the header)
  const newUpdatesBtn = document.getElementById('newUpdates');

  function updateNewUpdatesBanner(){
    try {
      if (!newUpdatesBtn) return;
      const count = pendingNewIndices.size || 0;
      if (count > 0) {
        newUpdatesBtn.textContent = `New updates (${count})`;
      } else {
        newUpdatesBtn.textContent = 'New updates available';
        newUpdatesBtn.style.display = 'none';
      }
    } catch (e) { /* ignore */ }
  }

  // Next-poll tracking (timestamp in ms)
  let nextPollAt = null;
  let countdownTimerId = null;

  function startCountdown() {
    if (!nextUpdateEl) return;
    if (countdownTimerId) clearInterval(countdownTimerId);
    countdownTimerId = setInterval(()=>{
      if (!nextPollAt) { nextUpdateEl.textContent = 'Next update: --'; return; }
      const sec = Math.max(0, Math.round((nextPollAt - Date.now())/1000));
      nextUpdateEl.textContent = `Next update: ${sec}s`;
    }, 250);
  }

  function scheduleNextPoll(afterSec) {
    nextPollAt = Date.now() + (afterSec * 1000);
    startCountdown();
  }

  // Toggle countdown and manual update UI depending on polling configuration
  if (!cfg.enablePoll) {
    if (nextUpdateEl) nextUpdateEl.style.display = 'none';
    if (manualUpdateBtn) {
      manualUpdateBtn.disabled = true;
      manualUpdateBtn.title = 'Polling disabled';
    }
  } else {
    if (manualUpdateBtn) manualUpdateBtn.title = 'Trigger immediate update';
  }

  // Expose a global rowCount helper so non-streaming code (poller, UI) can query
  // current number of rows without depending on the streaming IIFE's local function.
  function rowCount() {
    try {
      if (!table) return 0;
      return Math.max(0, table.rows().count());
    } catch (e) { return 0; }
  }

  function fmtInt(s){ const n = Number(s); return Number.isFinite(n)? n : null; }
  function safe(s){ return String(s ?? ""); }
  function isHttp(u){ return typeof u === 'string' && /^https?:\/\//i.test(u); }
  function toFixed4(n){ const x = Number(n); return Number.isFinite(x)? x.toFixed(4) : ""; }
  function degBucket10(n){
    const num = Number(n);
    if (!Number.isFinite(num)) return null;
    const rounded = Math.round(num);
    let b = Math.round(rounded/10)*10;
    b = ((b % 360) + 360) % 360;
    if (b === 360) b = 0;
    return b;
  }
  function angleAssetName(deg, dark){
    const b = degBucket10(deg);
    if (b==null) return null;
    return `arrow${b}_${dark? 'night':'day'}.png`;
  }

  // Swap existing angle image sources to match theme without re-rendering rows
  function updateAngleImagesForTheme(dark){
    const imgs = document.querySelectorAll('img.angle-img');
    imgs.forEach(img => {
      try {
        const src = img.getAttribute('src') || '';
        // Replace day/night suffix if present
        const newSrc = src.replace(/arrow(\d{1,3})_(day|night)\.png$/i, (m, num) => `arrow${num}_${dark ? 'night':'day'}.png`);
        if (newSrc !== src) img.setAttribute('src', newSrc);
      } catch(e) { /* per-image ignore */ }
    });
  }

  // 3) Seen rendering: two lines, small “still updating”, no “at”
  function formatSeen(secStr, completeFlag, preferTs){
    const s = Number(preferTs ?? secStr);
    if (!Number.isFinite(s)) return "";
    const nowMs = Date.now();
    const tsMs = s * 1000;
    const diffSec = Math.max(0, Math.floor((nowMs - tsMs)/1000));
    const rel = diffSec < 60 ? `${diffSec}s ago`
          : diffSec < 3600 ? `${Math.floor(diffSec/60)}m ago`
          : `${Math.floor(diffSec/3600)}h ago`;

    const dt = new Date(tsMs);
    // Use 24-hour clock (hour12: false) with two-digit hour for consistency
    const timeFmt = new Intl.DateTimeFormat(undefined, {
      hour: '2-digit', minute: '2-digit', timeZoneName: 'short', hour12: false
    });
    const timeStr = timeFmt.format(dt);

    const today = new Date();
    const sameDay = dt.getFullYear()===today.getFullYear()
                && dt.getMonth()===today.getMonth()
                && dt.getDate()===today.getDate();
    const dateStr = sameDay ? "" : new Intl.DateTimeFormat(undefined, {
      year:'numeric', month:'short', day:'numeric'
    }).format(dt);

    const updating = (String(completeFlag) !== 'true')
      ? `<div class="still-updating">· still updating</div>` : "";

    // Line 1: relative; Line 2: time (+ date if not today)
    return `<div class="mono">${rel}</div><div class="mono">${timeStr}${dateStr ? ' · ' + dateStr : ''}</div>${updating}`;
  }


  function hasSound(r){
    return r['sound:peak'] || r['sound:loudness'] || r['sound:color'] || r['noisegraph:link'];
  }
  function hasNotifications(r){
    return r['discord:link'] || r['bsky:link'] || r['telegram:link'] || r['mqtt:notified'];
  }

  // Normalize per-row values into typed fields so rendering is consistent
  function normalizeRow(r) {
    if (!r || typeof r !== 'object') return r;
    const out = Object.assign({}, r);
    out.HASNOISE = truthy(out.HASNOISE || out.hasOwnProperty('HASNOISE') && out.HASNOISE);
    out.HASIMAGES = truthy(out.HASIMAGES || out.hasOwnProperty('HASIMAGES') && out.HASIMAGES);
    out.HASROUTE = truthy(out.HASROUTE || out.hasOwnProperty('HASROUTE') && out.HASROUTE);
    out.complete = String(out.complete) === 'true' || out.complete === true;
    // Coerce notified flags
    out['discord:notified'] = truthy(out['discord:notified']);
    out['bsky:notified'] = truthy(out['bsky:notified']);
    out['telegram:notified'] = truthy(out['telegram:notified']);
    out['mqtt:notified'] = truthy(out['mqtt:notified']);
    // Numeric conversions
    out.index = Number(out.index);
    out['time:lastseen'] = Number(out['time:lastseen']) || Number(out['time:firstseen']) || 0;
    out['time:firstseen'] = Number(out['time:firstseen']) || 0;
    out['time:time_at_mindist'] = Number(out['time:time_at_mindist']) || 0;
    out['sound:peak'] = out['sound:peak'] !== '' ? out['sound:peak'] : null;
    out['sound:loudness'] = out['sound:loudness'] !== '' ? out['sound:loudness'] : null;
    return out;
  }

  // Small inline SVG icon helpers
  // Graph icon for noisegraph PNG link
  function iconNoise(){
    return `<svg class="ico" viewBox="0 0 24 24" aria-hidden="true" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M3 19h18v2H3z" opacity=".25"/><path d="M7 15h2v4H7v-4zm4-6h2v10h-2V9zm4 3h2v7h-2v-7zM3 12h2v10H3V12z"/></svg>`;
  }
  // Music/note icon for mp3 link
  function iconMp3(){
    return `<svg class="ico" viewBox="0 0 24 24" aria-hidden="true" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 3v10.55A4 4 0 1 0 14 17V7h4V3h-6z"/></svg>`;
  }
  function iconSpectro(){ return `<svg class="ico" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" xmlns="http://www.w3.org/2000/svg"><path d="M5 15h2V9H5v6zm3 3h2V6H8v12zm3-1h2V7h-2v10zm3-3h2V9h-2v5zm3 4h2V6h-2v12z"/></svg>` }
  // Notifier icons (simple inline SVGs for Discord, Telegram, Bluesky)
  function iconDiscord(){ return `<svg class="ico" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M20 4a16 16 0 0 0-4-.9l-.2.3c1.6.4 2.8 1 3.7 1.7-1.6-.8-3.2-1.3-4.9-1.6a16.2 16.2 0 0 0-5 0C7 3.7 5.4 4.2 3.8 5c.9-.7 2.1-1.3 3.7-1.7L7.3 3A16 16 0 0 0 3 4.1C1 7 0 10 0 13.1c2.1 2.2 4.8 3.8 7.9 4.4l.6-.9c-1.7-.5-3.2-1.3-4.5-2.4 1.6 1.2 3.6 2.1 5.8 2.5a17.3 17.3 0 0 0 6.5-.1c2.2-.4 4.2-1.3 5.8-2.5-1.3 1.1-2.8 1.9-4.5 2.4l.6.9a16.8 16.8 0 0 0 7.9-4.4C24 10 23 7 21 4.1zM8.7 14.6c-1 0-1.8-.9-1.8-2s.8-2 1.8-2 1.8.9 1.8 2-.8 2-1.8 2zm6.6 0c-1 0-1.8-.9-1.8-2s.8-2 1.8-2 1.8.9 1.8 2-.8 2-1.8 2z"/></svg>` }
  function iconTelegram(){ return `<svg class="ico" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M9.036 15.803l-.376 5.3c.539 0 .771-.231 1.048-.508l2.515-2.41 5.213 3.81c.957.528 1.64.252 1.9-.887l3.447-16.128h.001c.306-1.424-.514-1.979-1.449-1.63L1.4 9.79c-1.371.532-1.35 1.297-.233 1.64l5.8 1.811 13.476-8.51c.635-.387 1.217-.173.74.214L9.036 15.803z"/></svg>` }
  function iconBluesky(){ return `<svg class="ico" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M12 6c1.2-2 3.2-4 5.2-4 1.8 0 2.6 1.3 2.6 2.7 0 2.2-1.5 4.3-3.3 6 2.1-.5 4.5-1.7 5.5-3.4.6 3-2.2 5.4-5.5 6.7 2.8.7 5.1 2.1 5.1 4.2 0 1.4-1 2.2-2.4 2.2-2 0-4.2-1.9-6.2-4.2-2 2.4-4.2 4.2-6.2 4.2-1.4 0-2.4-.8-2.4-2.2 0-2.1 2.3-3.5 5.1-4.2-3.3-1.3-6.1-3.7-5.5-6.7 1 1.7 3.4 2.9 5.5 3.4-1.8-1.7-3.3-3.8-3.3-6C6.2 3.3 7 2 8.8 2 10.8 2 12.8 4 14 6h-2z"/></svg>` }
  function iconMQTT(){ return `<svg class="ico" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M12 2a10 10 0 100 20 10 10 0 000-20zm-1 5h2v6h-2V7zm1 10a1.5 1.5 0 110-3 1.5 1.5 0 010 3z"/></svg>` }

  // Helper to render notifier link with icon
  function notifierLink(href, label, iconHtml){
    const safeHref = String(href || '').replace(/"/g, '&quot;');
    return `<a class="chip" href="${safeHref}" target="_blank" rel="noopener">${iconHtml || ''}${label}</a>`;
  }

  // -------- Columns definition --------
  const viewCols = [
    { key:"idx", title:"#", width:"4%" },
    { key:"thumb", title:"", width:"6%" },
  { key:"when", title:"Time when closest" },
    { key:"aircraft", title:"Aircraft", width:"22%" },
  // Route column removed; route will be shown in Aircraft column after callsign
  // Position column slightly narrower (~70% of previous). Previous was 16%.
  { key:"position", title:"Position", width:"11%" },
    // Combined Alt/Spd column: both values shown on separate lines inside the same cell
  // Make Alt/Spd (speed) about 50% of previous width
  { key:"altspd", title:"Alt / Spd", width:"7%" },
    { key:"trk", title:"Track", width:"7%" },
  { key:"squawk", title:"Squawk", width:"8%" },
  { key:"sound", title:"Sound" },
    { key:"notify", title:"Notifications", width:"12%" }
  ];

  let table = null;
  // Map of index -> DataTables row API for fast incremental updates
  const rowByIndex = new Map();
  // Map of index -> consecutive-miss count used to implement a grace period before purging
  const missingCounts = new Map();
  // Track indices added since last user-visible redraw. Used to highlight new rows.
  const pendingNewIndices = new Set();

  function resetTableState(){
    try {
      if (table) table.clear().draw(false);
    } catch (e) { /* ignore */ }
    rowByIndex.clear();
    missingCounts.clear();
    pendingNewIndices.clear();
    updateNewUpdatesBanner();
    if (newUpdatesBtn) newUpdatesBtn.style.display = 'none';
    if (prog) prog.textContent = isPlaneAlertMode() ? 'Loading Plane-Alert…' : 'Loading…';
  }

  function highlightPendingNewRows(){
    try {
      if (!table) return;
      pendingNewIndices.forEach(idx => {
        const tr = document.querySelector(`tr[data-idx="${idx}"]`);
        if (tr) {
          tr.classList.add('pf-new-row');
          setTimeout(()=> tr.classList.remove('pf-new-row'), 2200);
        }
      });
      pendingNewIndices.clear();
    } catch (e) { /* ignore */ }
  }

  function redrawTable(forceFull=false){
    try {
      if (!table) return;
      const info = table.page ? table.page.info() : null;
      const onFirst = info && info.page === 0;
      if (forceFull || onFirst) {
        table.order([[0,'desc']]).page('first').draw(false);
        highlightPendingNewRows();
        if (newUpdatesBtn) newUpdatesBtn.style.display = 'none';
      } else {
        if (newUpdatesBtn) {
          newUpdatesBtn.style.display = 'inline-block';
          updateNewUpdatesBanner();
        }
        table.order([[0,'desc']]).draw(false);
      }
    } catch (e) { console.error('redraw error', e); }
  }

  // 2) DataTables init: numeric sort for idx, keep Seen desc
 function buildHeader(){
  theadRow.innerHTML = "";
  for (const c of viewCols){
    const th = document.createElement('th');
    th.textContent = c.title;
    if (c.width) th.style.width = c.width;
    theadRow.appendChild(th);
  }

  // Replace Alt / Spd header content with clickable sort controls for numeric sorting
  try {
    const altIdx = viewCols.findIndex(v => v.key === 'altspd');
    if (altIdx >= 0) {
      const th = theadRow.children[altIdx];
      if (th) {
        th.innerHTML = `Alt / Spd <span style="margin-left:.5rem; font-size:0.85em; color:var(--muted);">` +
          `<a href="#" id="sortAlt" title="Sort by altitude (toggle asc/desc)" style="margin-right:.4rem;">Alt</a>` +
          `<a href="#" id="sortSpd" title="Sort by speed (toggle asc/desc)">Spd</a>` +
          ` <span id="sortDir" class="mono" aria-hidden="true" style="margin-left:.25rem;"></span>`+
          `</span>`;
        // Wire click handlers which compute the Alt/Spd column index at runtime,
        // copy the chosen numeric attribute into data-order, and toggle
        // ascending/descending on each click.
        setTimeout(()=>{
          const aAlt = document.getElementById('sortAlt');
          const aSpd = document.getElementById('sortSpd');
          // determine column index dynamically from the header cell position
          const colIdx = (typeof th?.cellIndex === 'number') ? th.cellIndex : altIdx;

          const copyAttrToDataOrder = (attrName) => {
            try {
              const nodes = table.column(colIdx, {order:'applied'}).nodes();
              const arr = nodes.toArray ? nodes.toArray() : Array.from(nodes);
              for (const td of arr) {
                try {
                  const inner = td.querySelector && (td.querySelector(`[data-${attrName}]`) || td.querySelector('[data-order]')) || td;
                  if (inner && inner.setAttribute) {
                    const v = inner.getAttribute && inner.getAttribute(`data-${attrName}`);
                    if (v != null) inner.setAttribute('data-order', v);
                  }
                } catch(e) { /* per-cell ignore */ }
              }
            } catch(e) { console.warn('copyAttrToDataOrder failed', e); }
          };

          if (aAlt) aAlt.addEventListener('click', (ev)=>{
            ev.preventDefault();
            // Toggle direction state stored on the TH element
            try {
              const prev = th.dataset.altDir || 'desc';
              const dir = prev === 'asc' ? 'desc' : 'asc';
              th.dataset.altDir = dir;
              copyAttrToDataOrder('order-alt');
              table.settings()[0].aoColumns[colIdx].orderDataType = 'dom-data-order';
              const dirSpan = document.getElementById('sortDir');
              if (dirSpan) dirSpan.textContent = dir === 'asc' ? '▲' : '▼';
              table.order([[colIdx, dir]]).draw(false);
            } catch(e) { console.warn('sortAlt failed', e); }
          });

          if (aSpd) aSpd.addEventListener('click', (ev)=>{
            ev.preventDefault();
            try {
              const prev = th.dataset.spdDir || 'desc';
              const dir = prev === 'asc' ? 'desc' : 'asc';
              th.dataset.spdDir = dir;
              copyAttrToDataOrder('order-spd');
              table.settings()[0].aoColumns[colIdx].orderDataType = 'dom-data-order';
              const dirSpan = document.getElementById('sortDir');
              if (dirSpan) dirSpan.textContent = dir === 'asc' ? '▲' : '▼';
              table.order([[colIdx, dir]]).draw(false);
            } catch(e) { console.warn('sortSpd failed', e); }
          });
        }, 0);
      }
    }
  } catch (e) { /* ignore header wiring errors */ }

  // Create DataTable and capture API
  // Ordering plugin: read numeric value from an inner element's data-order attribute
  // and use that as the sort key for the column. This ensures the index column
  // sorts by the numeric index we embed in the rendered HTML.
  jQuery.fn.dataTable.ext.order['dom-data-order'] = function(settings, col) {
    return this.api().column(col, {order:'index'}).nodes().map(function(td){
      try {
        // If DataTables gives us an Element, query inside it
        if (td && td.querySelector) {
          const el = td.querySelector('[data-order]');
          if (el) {
            const v = el.getAttribute('data-order');
            const n = Number(v);
            return Number.isFinite(n) ? n : v;
          }
        }
        // Sometimes with deferRender DataTables may return a plain string for the cell.
        // Handle that by parsing the HTML string for data-order instead of using querySelector.
        if (typeof td === 'string') {
          const m = td.match(/data-order="(-?\d+)"/);
          if (m) return Number(m[1]);
        }
      } catch (e) { /* ignore */ }
      // fallback: parse numeric from text content (covers both Element and string)
      const txt = (td && td.textContent) ? td.textContent.trim() : (typeof td === 'string' ? td : '');
      const n2 = Number(txt.replace(/[^0-9.\-]/g,''));
      return Number.isFinite(n2) ? n2 : txt;
    });
  };

  // Ordering plugin for Altitude (reads numeric value from data-order-alt)
  jQuery.fn.dataTable.ext.order['dom-data-order-alt'] = function(settings, col) {
    return this.api().column(col, {order:'index'}).nodes().map(function(td){
      try {
        if (td && td.querySelector) {
          const el = td.querySelector('[data-order-alt]');
          if (el) {
            const v = el.getAttribute('data-order-alt');
            const n = Number(v);
            return Number.isFinite(n) ? n : v;
          }
        }
        if (typeof td === 'string') {
          const m = td.match(/data-order-alt="(-?\d+)"/);
          if (m) return Number(m[1]);
        }
      } catch (e) { /* ignore */ }
      const txt = (td && td.textContent) ? td.textContent.trim() : (typeof td === 'string' ? td : '');
      const n2 = Number(txt.replace(/[^0-9.\-]/g,''));
      return Number.isFinite(n2) ? n2 : txt;
    });
  };

  // Ordering plugin for Speed (reads numeric value from data-order-spd)
  jQuery.fn.dataTable.ext.order['dom-data-order-spd'] = function(settings, col) {
    return this.api().column(col, {order:'index'}).nodes().map(function(td){
      try {
        if (td && td.querySelector) {
          const el = td.querySelector('[data-order-spd]');
          if (el) {
            const v = el.getAttribute('data-order-spd');
            const n = Number(v);
            return Number.isFinite(n) ? n : v;
          }
        }
        if (typeof td === 'string') {
          const m = td.match(/data-order-spd="(-?\d+)"/);
          if (m) return Number(m[1]);
        }
      } catch (e) { /* ignore */ }
      const txt = (td && td.textContent) ? td.textContent.trim() : (typeof td === 'string' ? td : '');
      const n2 = Number(txt.replace(/[^0-9.\-]/g,''));
      return Number.isFinite(n2) ? n2 : txt;
    });
  };

  const api = $('#t').DataTable({
    dom: '<"pf-controls"<"pf-left"l><"pf-right"fip>>rt',
    // Enable deferRender for performance; ordering reads sort keys from data-order attributes with fallbacks.
    deferRender: true,
    pageLength: 25,
    responsive: true,
  // Default ordering: newest (highest index) first
  order: [[0, 'desc']],
    language: { emptyTable: 'Waiting for aircraft… Data will appear as it arrives.' },
    columns: viewCols.map(_ => ({ title: _.title })),
    columnDefs: [
      // Use our dom-data-order plugin for column 0 (index) so sorting honors
      // the numeric value placed in the cell's data-order attribute.
      {
        targets: 0,
        orderDataType: 'dom-data-order',
        type: 'num',
        // Ensure numeric sort even if the order plugin isn't engaged by parsing
        // the data-order attribute or falling back to numeric text extraction.
        render: {
          _: function(data) { return data; },
          sort: function(data) {
            try {
              const s = String(data || '');
              const m = s.match(/data-order="(-?\d+)"/);
              if (m) return Number(m[1]);
              const n = Number(s.replace(/[^0-9.\-]/g, ''));
              return Number.isFinite(n) ? n : 0;
            } catch (e) { return 0; }
          }
        }
      },
      // For Alt/Spd column (index 5 in viewCols), allow numeric ordering by
      // altitude or by speed via our custom orderDataType plugins. We'll
      // wire header click handlers to call the appropriate ordering.
      { targets: 5, orderDataType: 'dom-data-order-alt' },
      { targets: "_all", render: (data)=>data }
    ],
    createdRow: function(row, data){
      // Mark rows that are still updating
      if ((data?.[2] || '').includes('still-updating')) {
        row.classList.add('row-incomplete');
      } else {
        row.classList.remove('row-incomplete');
      }

      // Try to extract numeric index from the first-cell HTML and stash it on the TR.
      try {
        const first = data && data[0] ? String(data[0]) : '';
        const m = first.match(/data-order="(-?\d+)"/);
        if (m) {
          const id = Number(m[1]);
          row.dataset.idx = id;
          // If the table API is available, store the API row reference for fast lookup
          if (table) rowByIndex.set(id, table.row(row));
        }
      } catch (e) { /* ignore */ }
    }
  });

  // Store globally if you need it
  table = api;
  window.table = api;

  // Preserve top row when the page length changes: capture current display start
  // and restore it after DataTables applies the new length. This keeps the
  // same top row visible and lets additional rows appear below it.
  try {
    const lenSel = document.querySelector('#t_length select');
    if (lenSel) {
      let anchorIdx = null;
      // On focus store the numeric index value from the first logical row using DOM if available.
      // Using DOM is more robust now that deferRender is disabled; fallback to column data if needed.
      lenSel.addEventListener('focus', ()=>{
        try {
          const info = table.page ? table.page.info() : null;
          if (!info) return;
          const start = info.start || 0;
          // Prefer reading from the visible DOM row if present
          const tr = document.querySelector('#t tbody tr');
          if (tr && tr.dataset && tr.dataset.idx) {
            anchorIdx = Number(tr.dataset.idx);
            return;
          }
          // Fallback: use column data
          const colData = table.column(0, {order: 'applied'}).data();
          if (!colData || colData.length === 0) { anchorIdx = null; return; }
          const cell = String(colData[start] || '');
          const m = cell.match(/data-order="(-?\d+)"/);
          anchorIdx = m ? Number(m[1]) : null;
        } catch (e) { anchorIdx = null; }
      });

      lenSel.addEventListener('change', ()=>{
        try {
          if (anchorIdx == null) return;
          // After the change, give DataTables a tick to reflow, then try to locate the
          // same anchor index in the newly ordered column data. We aggressively
          // invalidate rows to ensure data() returns DOM/HTML we can parse.
          setTimeout(()=>{
            try {
              try { table.rows().invalidate(); } catch(e) { /* ignore */ }
              const col = table.column(0, {order: 'applied'});
              const colDataArr = col.data().toArray ? col.data().toArray() : Array.from(col.data());
              const ids = colDataArr.map(c => {
                const s = String(c || '');
                const m = s.match(/data-order="(-?\d+)"/);
                return m ? Number(m[1]) : null;
              });
              const pos = ids.indexOf(Number(anchorIdx));
              if (pos >= 0) {
                const newPage = Math.floor(pos / table.page.len());
                table.page(newPage).draw(false);
              } else {
                // Fallback: go to first page so user sees newest rows
                table.page('first').draw(false);
              }
            } catch (e) { console.warn('anchor restore failed', e); table.page('first').draw(false); }
            anchorIdx = null;
          }, 50);
        } catch (e) { anchorIdx = null; }
      });
    }
  } catch(e) { /* ignore */ }

  // Populate rowByIndex for any rows DataTables already created during init
  try {
    api.rows().every(function(){
      const tr = this.node();
      if (!tr) return;
      const d = this.data();
      const first = d && d[0] ? String(d[0]) : '';
      const m = first.match(/data-order="(-?\d+)"/);
      if (m) {
        const id = Number(m[1]);
        tr.dataset.idx = id;
        rowByIndex.set(id, api.row(tr));
      }
    });
  } catch (e) { /* ignore */ }

  // Bind draw handler AFTER api exists
  api.on('draw', function(){
    // Only rows in the current page are guaranteed to have nodes
    api.rows({ page: 'current' }).every(function(){
      const tr = this.node();
      if (!tr) return; // node may be null when not in DOM
      const seenCell = (this.data()?.[2] || '');
      if (seenCell.includes('still-updating')) tr.classList.add('row-incomplete');
      else tr.classList.remove('row-incomplete');
    });
  });
}

// Helper: expand comma-separated discord links in the Notifications column.
// If a cell contains a single anchor whose href contains commas (multiple URLs),
// or if the cell has a data-discord-links attribute with comma-separated URLs,
// create an anchor for each URL labeled 'Discord'. This runs after table draws
// so it will affect both streaming and polled updates.
function expandDiscordLinksInNotifications() {
  try {
    if (!table) return;
    // Find all cells in the Notifications column (last column index)
    const notifColIdx = viewCols.findIndex(c => c.key === 'notify');
    if (notifColIdx === -1) return;
    // For each visible row cell in the column
    table.column(notifColIdx, {page: 'current'}).nodes().each(function(td){
      try {
        const cell = td instanceof Element ? td : (td && td.node) ? td.node : null;
        if (!cell) return;

        // First, check for a data attribute with comma-separated links
        const dataVal = cell.getAttribute && cell.getAttribute('data-discord-links');
        let links = null;
        if (dataVal) {
          links = dataVal.split(',').map(s => s.trim()).filter(Boolean);
        } else {
          // Otherwise, if there's exactly one anchor, look at its raw attribute value
          const anchors = cell.querySelectorAll && cell.querySelectorAll('a');
          if (anchors && anchors.length === 1) {
            const a = anchors[0];
            const rawHref = a.getAttribute && a.getAttribute('href');
            if (rawHref && rawHref.includes(',')) {
              links = rawHref.split(',').map(s => s.trim()).filter(Boolean);
            }
          }
          // If no anchors or single-anchor case didn't detect commas, also try plain text (comma-separated URLs)
          if (!links) {
            const txt = (cell.textContent || '').trim();
            if (txt && txt.includes(',')) {
              // Split and keep probable URLs (simple heuristic: starts with http or /)
              const candidates = txt.split(',').map(s => s.trim()).filter(Boolean);
              const probable = candidates.filter(s => /^https?:\/\//i.test(s) || s.startsWith('/'));
              if (probable.length > 0) links = probable;
            }
          }
        }

        if (!links || links.length <= 1) return; // nothing to do

        // Clear existing content and append an anchor per link, separated by middot
        cell.innerHTML = '';
        const multi = links.length > 1;
        links.forEach((lnk, i) => {
          const a = document.createElement('a');
          a.href = lnk;
          a.target = '_blank';
          a.rel = 'noopener';
          a.textContent = multi ? `Discord (${i+1})` : 'Discord';
          cell.appendChild(a);
          if (i !== links.length - 1) cell.appendChild(document.createTextNode(' · '));
        });
      } catch (e) { /* per-cell ignore */ }
    });
  } catch (e) { console.warn('expandDiscordLinksInNotifications failed', e); }
}

// Hook into DataTables draw event so newly-rendered pages have expanded links
if (typeof table !== 'undefined' && table) {
  table.on && table.on('draw', expandDiscordLinksInNotifications);
}

// Also call once after initial setup if table exists
setTimeout(()=> expandDiscordLinksInNotifications(), 150);

// 5) Render row with row class + position split link + numeric idx data source
function renderRow(r) {
  const idx = fmtInt(r.index) ?? safe(r.index);
  const idxVal = fmtInt(r.index);
  const idxCell = idxVal != null
    ? `<span class="mono" data-order="${idxVal}">${idxVal}</span>`
    : `<span class="mono">${safe(r.index)}</span>`;

  // Seen
  const lastSeen = r["time:lastseen"] || "";
  const firstSeen = r["time:firstseen"] || "";
  const atMindist = r["time:time_at_mindist"] || "";
  const whenHtml = (atMindist || lastSeen || firstSeen)
    ? formatSeen(lastSeen || firstSeen, r.complete, atMindist || lastSeen || firstSeen)
    : "";

  const icao = safe(r.icao);
  const tail = safe(r.tail);
  const cs = safe(r.callsign);
  const typ = safe(r.type);
  const owner = safe(r.owner);
  const tailFaaLink = safe(r["link:faa"]);
  const ownerFaLink = safe(r["link:fa"]);
  const tailHtml = tail ? (isHttp(tailFaaLink) ? `<a href="${tailFaaLink}" target="_blank" rel="noopener">${tail}</a>` : tail) : "";
  const ownerHtml = owner ? (isHttp(ownerFaLink) ? `<a href="${ownerFaLink}" target="_blank" rel="noopener">${owner}</a>` : owner) : "";
  const ownerLine = ownerHtml ? `<span class="muted">${ownerHtml}</span>` : "";
  // If a type is present, render it as a Skybrary link (lowercased). Encode the path component to be safe.
  const typHtml = typ ? (() => {
    try {
      const typePath = encodeURIComponent(String(typ).toLowerCase());
      const url = `https://skybrary.aero/aircraft/${typePath}`;
      return `<a href="${url}" target="_blank" rel="noopener">${typ}</a>`;
    } catch (e) { return typ; }
  })() : '';
  const route = safe(r.route);
  // Show route after callsign in the same Aircraft cell, unless it's 'n/a'
  const routeHtml = (route && route.toLowerCase() !== 'n/a') ? ` · ${route}` : '';
  // Right after the callsign, add the ICAO value when both exist
  const csIcaoLine = cs
    ? `${cs}${icao ? ' · ' + icao : ''}`
    : `${icao}`;
  const aircraft = `
    <div class="mono">${csIcaoLine}${routeHtml}</div>
    <div>${tailHtml ? tailHtml+' · ' : ''}${typHtml || typ}${ownerLine ? ' · ' + ownerLine : ''}</div>
  `.trim();

  // Position: coords link only; angle outside link; add N/E
  const lat = r.lat, lon = r.lon;
  const coordText = formatLatLon(lat, lon);
  const map = safe(r["link:map"]);
  const angleDegRaw = Number(r["angle:value"]);
  const angleDegInt = Number.isFinite(angleDegRaw) ? Math.round(angleDegRaw) : null;
  const angleName = r["angle:name"] ? ` (${safe(r["angle:name"])})` : "";
  const angleStr = angleDegInt != null ? `${angleDegInt}°${angleName}` : "";
  const angleImg = (() => {
    const a = angleAssetName(angleDegRaw, document.documentElement.classList.contains('dark'));
    return a ? `<img class="angle-img" alt="" src="${cfg.mediaBase}${a}">` : "";
  })();
  const coordsHtml = coordText
    ? (map ? `<a href="${map}" target="_blank" rel="noopener">${coordText}</a>` : coordText)
    : "";
  // Put coords on first line and angle (text + image) plus distance on the second line within the same cell.
  const angleCombined = [angleStr, angleImg].filter(Boolean).join('');
  // Distance + unit appended inline with the angle, separated by a middot
  const distNum = Number(r["distance:value"]);
  const distUnit = safe(r["distance:unit"] || "");
  let distStr = "";
  if (Number.isFinite(distNum)) {
    const formatted = distNum < 10 ? distNum.toFixed(1) : Math.round(distNum).toString();
    distStr = `${formatted} ${distUnit}`.trim();
  } else if (r["distance:value"]) {
    distStr = `${safe(r["distance:value"]) } ${distUnit}`.trim();
  }
  const angleLine = [angleCombined, distStr].filter(Boolean).join(' · ');
  const positionInner = [
    coordsHtml ? `<div>${coordsHtml}</div>` : '',
    angleLine ? `<div>${angleLine}</div>` : ''
  ].filter(Boolean).join('');
  const position = positionInner ? `<div class="position-cell">${positionInner}</div>` : "";

  const altRaw = Number(r["altitude:value"]);
  const altVal = Number.isFinite(altRaw) ? `${safe(r["altitude:value"])} ${safe(r["altitude:unit"] || "ft")}` : "";
  const spdNum = fmtInt(r["groundspeed:value"]);
  const spdUnit = safe(r["groundspeed:unit"] || "kt");
  const spdVal = spdNum != null ? `${spdNum} ${spdUnit}` : "";
  // Choose numeric ordering priority: altitude (feet) if present, else groundspeed (kt), else 0
  const numericOrder = Number.isFinite(altRaw) ? altRaw : (spdNum != null ? spdNum : 0);
  // Combine altitude and speed into a single cell (altitude on first line, speed on second if present)
  const altspdInner = [altVal ? `<div class="mono">${altVal}</div>` : '', spdVal ? `<div class="mono">${spdVal}</div>` : ''].filter(Boolean).join('');
  // Include separate numeric attributes for altitude and speed to allow
  // independent numeric sorting when a user clicks Alt or Spd in the header.
  const altAttr = Number.isFinite(altRaw) ? altRaw : '';
  const spdAttr = spdNum != null ? spdNum : '';
  const altspd = `<div data-order-alt="${altAttr}" data-order-spd="${spdAttr}">${altspdInner}</div>`;

  const trackDegRaw = Number(r["track:value"]);
  const trackDegInt = Number.isFinite(trackDegRaw) ? Math.round(trackDegRaw) : null;
  const trackName = r["track:name"] ? ` (${safe(r["track:name"])})` : "";
  const trkStr = trackDegInt != null ? `${trackDegInt}°${trackName}` : "";
  const trkImg = (() => {
    const a = angleAssetName(trackDegRaw, document.documentElement.classList.contains('dark'));
    return a ? `<img class="angle-img" alt="" src="${cfg.mediaBase}${a}">` : "";
  })();
  const trk = trkStr ? `${trkStr}${trkImg}` : "";

  const thumbUrl = r["image:thumblink"];
  let thumbEl = "";
  if (isHttp(thumbUrl)) {
    thumbEl = `<img class="thumb" loading="lazy" data-src="${thumbUrl.replace(/"/g,'&quot;')}" alt="thumb">`;
  } else {
    // Fallback: show silhouette based on aircraft type code (e.g., PC21.bmp) if available
    const typCodeRaw = safe(r.type || '');
    const code = typCodeRaw.replace(/[^A-Za-z0-9]/g,'').toUpperCase();
    if (code) {
      const base = cfg.silhouetteDir || (cfg.mediaBase + 'silhouettes/');
      const silSrc = `${base}${code}.bmp`;
      // Hide the image if the silhouette is not found
  thumbEl = `<img class="thumb thumb-sil" loading="lazy" data-src="${silSrc.replace(/"/g,'&quot;')}" alt="silhouette ${code}" onerror="this.style.display='none'">`;
    }
  }

  const spectro = safe(r["spectro:link"]);
  const noise = safe(r["noisegraph:link"]);
  const mp3 = safe(r["mp3:link"]);

  const notifyLinks = [];
  const discordLink = r["discord:link"];
  const bskyLink = r["bsky:link"];
  const telegramLink = r["telegram:link"];
  const mqttFlag = r["mqtt:notified"];
  const discordNotified = truthy(r["discord:notified"]);
  const bskyNotified = truthy(r["bsky:notified"]);
  const telegramNotified = truthy(r["telegram:notified"]);
  const mqttNotified = truthy(mqttFlag);

  if (discordLink) {
    // discord:link may be a comma-separated list of URLs; render each as its own anchor
    const links = String(discordLink)
      .split(',')
      .map(s => s.trim())
      .filter(Boolean);
    const multi = links.length > 1;
    for (let i = 0; i < links.length; i++) {
      const lnk = links[i];
      const label = multi ? `Discord (${i+1})` : 'Discord';
      notifyLinks.push(notifierLink(lnk, label, iconDiscord()));
    }
  } else if (discordNotified) {
    notifyLinks.push(`<span class="chip muted has-tooltip" title="There's no link associated with this notification">${iconDiscord()}<span class="label">Discord</span></span>`);
  }

  if (bskyLink) notifyLinks.push(notifierLink(bskyLink, 'Bluesky', iconBluesky()));
  else if (bskyNotified) notifyLinks.push(`<span class="chip muted has-tooltip" title="There's no link associated with this notification">${iconBluesky()}<span class="label">Bluesky</span></span>`);

  if (telegramLink) notifyLinks.push(notifierLink(telegramLink, 'Telegram', iconTelegram()));
  else if (telegramNotified) notifyLinks.push(`<span class="chip muted has-tooltip" title="There's no link associated with this notification">${iconTelegram()}<span class="label">Telegram</span></span>`);

  if (mqttNotified) notifyLinks.push(`<span class="chip muted has-tooltip" title="There's no link associated with this notification">${iconMQTT()}<span class="label">MQTT</span></span>`);

  // Sound column: show a small chip with peak/loud info, and separate small clickable badges for noisegraph and mp3 if present.
  let sound = "";
  const parts = [];
  if (hasSound(r)) {
  const peak = r["sound:peak"] ? `Peak ${safe(r["sound:peak"]) } dbFS` : "";
  const loud = r["sound:loudness"] ? `Loud ${safe(r["sound:loudness"]) } dB` : "";
  const dot = r["sound:color"] ? `<span class="dot" style="background:${safe(r["sound:color"]) }"></span>` : "";
    const inner = `<span class="chip">${dot}${[peak, loud].filter(Boolean).join(' · ')}</span>`;
    parts.push(inner);
  }
  // Build Sound column in two lines: first Peak/Loudness, then the chip links below
  let measurementChip = '';
  if (hasSound(r)) {
    const peak = r["sound:peak"] ? `Peak ${safe(r["sound:peak"]) } dbFS` : "";
    const loud = r["sound:loudness"] ? `Loud ${safe(r["sound:loudness"]) } dB` : "";
    const dot = r["sound:color"] ? `<span class="dot" style="background:${safe(r["sound:color"]) }"></span>` : "";
    measurementChip = `<span class="chip">${dot}${[peak, loud].filter(Boolean).join(' · ')}</span>`;
  }
  const linkChips = [];
  // Noisegraph badge
  if (noise) {
    const nUrl = safe(noise);
    const nBadge = iconNoise();
    linkChips.push(`<a class="chip" href="${nUrl}" target="_blank" rel="noopener" title="Show noisegraph" aria-label="Show noisegraph">${nBadge}</a>`);
  }
  // Spectrogram badge (distinct icon)
  if (spectro) {
    const sUrl = safe(spectro);
    const sBadge = iconSpectro();
    linkChips.push(`<a class="chip" href="${sUrl}" target="_blank" rel="noopener" title="Show spectrogram" aria-label="Show spectrogram">${sBadge}</a>`);
  }
  // MP3 badge
  if (mp3) {
    const mUrl = safe(mp3);
    const mBadge = iconMp3();
    linkChips.push(`<a class="chip" href="${mUrl}" target="_blank" rel="noopener" title="Play audio" aria-label="Play audio">${mBadge}</a>`);
  }
  if (measurementChip && linkChips.length) sound = `<div>${measurementChip}</div><div>${linkChips.join(' ')}</div>`;
  else if (measurementChip) sound = measurementChip;
  else if (linkChips.length) sound = `<div>${linkChips.join(' ')}</div>`;

  const squawkVal = safe(r["squawk:value"]);
  const squawkDesc = r["squawk:description"] ? ` <span class="muted">(${safe(r["squawk:description"])})</span>` : "";
  const isEmerg = squawkVal === "7500" || squawkVal === "7600" || squawkVal === "7700";
  const squawk = squawkVal ? `<span class="${isEmerg ? 'danger' : ''} mono">${squawkVal}</span>${squawkDesc}` : "";

  return {
    row: [
    `${idxCell}`,
    `${thumbEl}`,
    `${whenHtml}`,
  `${aircraft}`,
  `${position}`,
  `${altspd}`,
    `${trk}`,
    `${squawk}`,
    `${sound}`,
    `${notifyLinks.join(' ')}`
  ],
    incomplete: String(r.complete) !== 'true'
  };
}


// 6) Prepend newest-first during streaming and apply row class
function addOrUpdateRow(r){
  const rendered = renderRow(r);
  const idxVal = fmtInt(r.index);
  if (Number.isFinite(idxVal) && rowByIndex.has(idxVal)) {
    try {
      const apiRow = rowByIndex.get(idxVal);
      apiRow.data(rendered.row);
      return { api: apiRow, created: false, idx: idxVal };
    } catch (e) {
      console.warn('row update failed, falling back to add', e);
      rowByIndex.delete(idxVal);
    }
  }

  const apiRow = table.row.add(rendered.row);
  try {
    const first = rendered.row && rendered.row[0] ? String(rendered.row[0]) : '';
    const m = first.match(/data-order="(-?\d+)"/);
    const id = Number.isFinite(idxVal) ? idxVal : (m ? Number(m[1]) : null);
    if (Number.isFinite(id)) {
      const node = apiRow.node();
      if (node) node.dataset.idx = id;
      rowByIndex.set(id, apiRow);
      return { api: apiRow, created: true, idx: id };
    }
  } catch (e) { /* ignore */ }
  return { api: apiRow, created: true, idx: idxVal };
}

  // 4) Position: link only coords, add N/E; angle outside link
  function formatLatLon(lat, lon){
    const latNum = Number(lat);
    const lonNum = Number(lon);
    if (!Number.isFinite(latNum) || !Number.isFinite(lonNum)) return "";
    return `${toFixed4(latNum)}&deg; N, ${toFixed4(lonNum)}&deg; E`;
  }

  function applyMediaPrefixes(row){
    if (!cfg.noisePrefix || !row || typeof row !== 'object') return;
    const keys = ['noisegraph:link','spectro:link','mp3:link'];
    const prefix = cfg.noisePrefix;
    keys.forEach(key => {
      const val = row[key];
      if (val && !val.startsWith('http') && !val.startsWith(prefix)) {
        row[key] = prefix + val;
      }
    });
  }

  if (!table) buildHeader();
  restartDataPipelines();


  async function startStreamReader(generation){
    if (!cfg.enableStream) return;
    stopStreamReader();
    const controller = new AbortController();
    streamAbortController = controller;
    const modeForRun = dataMode;
    try {
      const resp = await fetch(buildStreamUrl(modeForRun), { cache: 'no-store', signal: controller.signal });
      if (!resp.ok || !resp.body) { if (prog) prog.textContent = 'Stream failed'; return; }

      const reader = resp.body.getReader();
      const dec = new TextDecoder();
      let buf = '';
      let added = 0;
      let seenHeader = false;
      let streamGlobals = {};

      function setStreamGlobals(g) {
        streamGlobals = {};
        if (!g || typeof g !== 'object') return;
        streamGlobals.HASNOISE = truthy(g.HASNOISE || g.hasOwnProperty('HASNOISE') && g.HASNOISE);
        streamGlobals.HASIMAGES = truthy(g.HASIMAGES || g.hasOwnProperty('HASIMAGES') && g.HASIMAGES);
        streamGlobals.HASROUTE = truthy(g.HASROUTE || g.hasOwnProperty('HASROUTE') && g.HASROUTE);
        streamGlobals.LASTUPDATE = Number(g.LASTUPDATE) || 0;
        streamGlobals.maxindex = Number(g.maxindex) || 0;
        for (const k of Object.keys(g)) if (!(k in streamGlobals)) streamGlobals[k] = g[k];
      }

      while (true) {
        if (generation !== modeGeneration || controller.signal.aborted) return;
        const {value, done} = await reader.read();
        if (done) break;
        buf += dec.decode(value, {stream:true});
        let nl;
        while ((nl = buf.indexOf('\n')) >= 0) {
          if (generation !== modeGeneration || controller.signal.aborted) return;
          const line = buf.slice(0, nl); buf = buf.slice(nl+1);
          if (!line.trim()) continue;
          let obj;
          try { obj = JSON.parse(line); } catch(e){ console.error('Bad JSON:', e, line); continue; }
          if (obj && obj.__globals) {
            setStreamGlobals(obj.__globals || {});
            if (streamGlobals.LASTUPDATE && Number.isFinite(streamGlobals.LASTUPDATE) && streamGlobals.LASTUPDATE > 0) {
              const dt = new Date(streamGlobals.LASTUPDATE * 1000);
              const hh = String(dt.getHours()).padStart(2,'0');
              const mm = String(dt.getMinutes()).padStart(2,'0');
              lastUpdateEl.textContent = `Last update: ${hh}:${mm}`;
            }
            if (streamGlobals.maxindex && streamGlobals.maxindex > 0 && prog) {
              prog.textContent = `Loaded 0 / ${streamGlobals.maxindex}`;
            }
            continue;
          }

          if (!seenHeader && obj && obj.__columns) {
            seenHeader = true;
            continue;
          }
          if (obj && typeof obj === 'object' && Object.keys(obj).length === 1 && obj.error) {
            if (prog) prog.textContent = `Error: ${obj.error}`;
            continue;
          }
          const payload = (obj && typeof obj === 'object')
            ? Object.assign({}, streamGlobals, obj)
            : obj;

          applyMediaPrefixes(payload);

          const norm = normalizeRow(payload);
          if (!norm || !norm.icao || String(norm.icao).trim() === '') {
            continue;
          }
          const res = addOrUpdateRow(norm);
          if (res.created && Number.isFinite(Number(res.idx))) {
            pendingNewIndices.add(Number(res.idx));
            updateNewUpdatesBanner();
          }
          added++;
          if (added % 10 === 0) {
            if (generation !== modeGeneration || controller.signal.aborted) return;
            redrawTable(false);
            if (prog) prog.textContent = `Loaded ${rowCount()}…`;
          }
        }
      }

      if (buf.trim()) {
        try {
          const last = JSON.parse(buf);
          if (generation !== modeGeneration || controller.signal.aborted) return;
          const res = addOrUpdateRow(last);
          if (res.created && Number.isFinite(Number(res.idx))) {
            pendingNewIndices.add(Number(res.idx));
            updateNewUpdatesBanner();
          }
        } catch(e) { /* ignore parse */ }
      }
      if (generation !== modeGeneration || controller.signal.aborted) return;
      redrawTable(true);
      if (prog && !prog.textContent.startsWith('Error')) prog.textContent = `Done. Rows: ${rowCount()}`;
    } catch (e) {
      if (controller.signal.aborted || generation !== modeGeneration) return;
      console.error('stream error', e);
      if (prog) prog.textContent = 'Stream error';
    } finally {
      if (streamAbortController === controller) streamAbortController = null;
    }
  }

  function stopStreamReader(){
    if (streamAbortController) {
      try { streamAbortController.abort(); } catch (e) { /* ignore */ }
      streamAbortController = null;
    }
  }

// -------- Polling snapshot every 60s and apply incremental updates --------
// Uses same endpoint (`./cgi/pfstream.sh`) which emits NDJSON (globals, schema, rows)
// and updates existing rows (by index) or appends new rows. Does a single draw at end.
async function pollAndMerge(modeForRun, generation) {
  try {
    if (generation !== modeGeneration) return;
    const resp = await fetch(buildStreamUrl(modeForRun), { cache: 'no-store' });
    if (!resp.ok) { console.warn('poll: fetch failed', resp.status); return; }
    if (generation !== modeGeneration) return;
    const txt = await resp.text();
    if (generation !== modeGeneration) return;
    if (!txt) return;

    const lines = txt.split('\n');
    let localGlobals = {};
    let seenHeader = false;
  const toAdd = [];
  const toUpdate = [];
  // Track which numeric indices were present in the latest snapshot so we can purge missing rows
  const seenIndices = new Set();

    for (const line of lines) {
      if (!line.trim()) continue;
      let obj;
      try { obj = JSON.parse(line); } catch (e) { console.warn('poll: bad json', e, line); continue; }
      if (obj && obj.__globals) { localGlobals = obj.__globals || {};
        if (localGlobals.LASTUPDATE && Number.isFinite(Number(localGlobals.LASTUPDATE)) && Number(localGlobals.LASTUPDATE) > 0) {
          const dt = new Date(Number(localGlobals.LASTUPDATE) * 1000);
          const hh = String(dt.getHours()).padStart(2,'0');
          const mm = String(dt.getMinutes()).padStart(2,'0');
          lastUpdateEl.textContent = `Last update: ${hh}:${mm}`;
        }
        continue; }
      if (!seenHeader && obj && obj.__columns) { seenHeader = true; continue; }
      if (!obj || typeof obj !== 'object') continue;

      const payload = Object.assign({}, localGlobals, obj);
      applyMediaPrefixes(payload);

  const norm = normalizeRow(payload);
  // Ignore records without an ICAO value
  if (!norm || !norm.icao || String(norm.icao).trim() === '') continue;
      const rendered = renderRow(norm);

      // Fast lookup: use rowByIndex map to find existing row by numeric index
      const numericIdx = Number(norm.index);
      if (Number.isFinite(numericIdx)) seenIndices.add(numericIdx);
      const foundApi = Number.isFinite(numericIdx) ? rowByIndex.get(numericIdx) : null;
      if (foundApi) {
        // Existing row: update and clear any missing counter
        toUpdate.push({ api: foundApi, row: rendered.row, idx: numericIdx });
        missingCounts.delete(numericIdx);
      } else {
        // New row: add and clear any missing counter (might have been previously missing)
        toAdd.push({ row: rendered.row, idx: numericIdx });
        missingCounts.delete(numericIdx);
      }
    }

    if (generation !== modeGeneration) return;

    // Apply updates
    for (const u of toUpdate) {
      try {
        // Prefer direct API update. Some API objects may be stale before a draw,
        // so if this fails, fall back to locating the row node by data-idx.
        u.api.data(u.row);
      } catch(e) {
        console.warn('poll: update failed via api, trying fallback', e, u && u.idx);
        try {
          if (Number.isFinite(u.idx)) {
            const tr = document.querySelector(`tr[data-idx="${u.idx}"]`);
            if (tr) table.row(tr).data(u.row);
            else console.warn('poll: fallback row not found for idx', u.idx);
          }
        } catch (ee) { console.warn('poll: fallback update failed', ee); }
      }
    }
    // Append new rows and register them in rowByIndex
    for (const item of toAdd) {
      const apiRow = table.row.add(item.row);
      // If we know the numeric index, register the newly added row in the map
      try {
        if (Number.isFinite(item.idx)) {
          const node = apiRow.node();
          if (node) node.dataset.idx = item.idx;
          rowByIndex.set(item.idx, apiRow);
          // mark as pending so banner/highlight will show
          pendingNewIndices.add(Number(item.idx));
        } else {
          // Fallback: attempt to parse from the first-cell HTML
          const first = item.row && item.row[0] ? String(item.row[0]) : '';
          const m = first.match(/data-order="(-?\d+)"/);
          if (m) {
            const id = Number(m[1]);
            const node = apiRow.node();
            if (node) node.dataset.idx = id;
            rowByIndex.set(id, apiRow);
            pendingNewIndices.add(Number(id));
          }
        }
      } catch (e) { /* ignore */ }
    }

    // After applying updates/adds, purge any rows not present in the snapshot.
    // Purge rows that have been absent for at least 2 consecutive polls
    let purged = 0;
    try {
      for (const [idx, apiRow] of rowByIndex.entries()) {
        const nidx = Number(idx);
        if (seenIndices.has(nidx)) continue; // present in this snapshot

        // Increment miss counter
  if (generation !== modeGeneration) return;

        const prev = missingCounts.get(nidx) || 0;
        const now = prev + 1;
        missingCounts.set(nidx, now);

        // If absent for 2 or more polls, purge it
        if (now >= 2) {
          try {
            const node = apiRow.node();
            if (node) table.row(node).remove();
          } catch (e) { /* ignore per-row remove errors */ }
          rowByIndex.delete(nidx);
          missingCounts.delete(nidx);
          purged++;
        }
      }
    } catch (e) { console.warn('poll: purge failed', e); }

    // Single redraw to refresh display (preserve paging)
    if (toUpdate.length || toAdd.length || purged) {
      redrawTable(false);
      // After the draw, ensure any newly-created row nodes are registered in rowByIndex.
      try {
        table.rows().every(function(){
          const tr = this.node();
          if (!tr) return;
          // If the TR already has an idx, ensure the map contains it
          if (tr.dataset && tr.dataset.idx) {
            const id = Number(tr.dataset.idx);
            if (Number.isFinite(id) && !rowByIndex.has(id)) rowByIndex.set(id, table.row(tr));
            return;
          }
          // Otherwise try to parse the first-cell HTML for data-order and set dataset
          try {
            const d = this.data();
            const first = d && d[0] ? String(d[0]) : '';
            const m = first.match(/data-order="(-?\d+)"/);
            if (m) {
              const id = Number(m[1]);
              tr.dataset.idx = id;
              if (Number.isFinite(id)) rowByIndex.set(id, table.row(tr));
            }
          } catch (e) { /* ignore per-row */ }
        });
      } catch (e) { console.warn('poll: post-draw registration failed', e); }
  // If new rows were added during the poll, update the banner count.
  if (toAdd.length) updateNewUpdatesBanner();
  if (prog) prog.textContent = `Updated ${toUpdate.length} / Added ${toAdd.length} / Purged ${purged} — Rows: ${rowCount()}`;
    }
  } catch (e) {
    console.error('pollAndMerge error', e);
  }
}

  function stopPollingLoop(){
    if (pollIntervalHandle) {
      clearInterval(pollIntervalHandle);
      pollIntervalHandle = null;
    }
    nextPollAt = null;
    startCountdown();
  }

  function startPollingLoop(generation){
    if (!cfg.enablePoll) return;
    stopPollingLoop();
    const intervalMs = (cfg.pollIntervalSec || 60) * 1000;
    const runOnce = async ()=>{
      const modeForRun = dataMode;
      await pollAndMerge(modeForRun, generation);
      if (generation === modeGeneration) scheduleNextPoll(cfg.pollIntervalSec || 60);
    };
    runOnce().catch(e => console.error('poll loop run', e));
    pollIntervalHandle = setInterval(()=> runOnce().catch(e => console.error('poll loop run', e)), intervalMs);
  }

  function restartDataPipelines(){
    modeGeneration++;
    resetTableState();
    stopStreamReader();
    stopPollingLoop();
    if (cfg.enableStream) startStreamReader(modeGeneration);
    if (cfg.enablePoll) startPollingLoop(modeGeneration);
  }

// Manual Update button: trigger immediate poll
manualUpdateBtn?.addEventListener('click', async ()=>{
  if (!cfg.enablePoll) return;
  // Provide immediate feedback: disable button while running
  try {
    manualUpdateBtn.disabled = true;
    const prevText = manualUpdateBtn.textContent;
    manualUpdateBtn.textContent = 'Updating…';
    if (prog) prog.textContent = 'Updating…';
    const gen = modeGeneration;
    const modeForRun = dataMode;
    await pollAndMerge(modeForRun, gen);
    if (gen === modeGeneration) scheduleNextPoll(cfg.pollIntervalSec || 60);
    manualUpdateBtn.textContent = prevText;
  } catch (e) {
    console.error('Manual update failed', e);
    if (prog) prog.textContent = 'Update failed';
  } finally {
    manualUpdateBtn.disabled = false;
  }
});

// New-updates banner: when user clicks, jump to first page and show new rows
if (newUpdatesBtn) {
  newUpdatesBtn.addEventListener('click', ()=>{
    try {
      if (table) {
        table.page('first').draw(false);
        // After jumping, highlight pending rows
        highlightPendingNewRows();
      }
      newUpdatesBtn.style.display = 'none';
    } catch (e) { console.error('newUpdates click', e); }
  });
}

</script>

<script>
// Lazy-load images using IntersectionObserver (thumb and spectro)
function lazyLoadImagesIn(container){
  try {
    const root = container || document;
    const imgs = root.querySelectorAll('img[data-src]');
    if (!imgs || imgs.length === 0) return;
    if ('IntersectionObserver' in window) {
      const io = new IntersectionObserver((entries, obs)=>{
        for (const e of entries) {
          if (e.isIntersecting) {
            const img = e.target;
            const src = img.getAttribute('data-src');
            if (src) { img.src = src; img.removeAttribute('data-src'); }
            obs.unobserve(img);
          }
        }
      }, { root: null, rootMargin: '100px', threshold: 0.01 });
      imgs.forEach(img => io.observe(img));
    } else {
      imgs.forEach(img => { const src = img.getAttribute('data-src'); if (src) { img.src = src; img.removeAttribute('data-src'); } });
    }
  } catch (e) { /* ignore */ }
}

// Observe DataTables draws to (re)apply lazy loading
document.addEventListener('DOMContentLoaded', ()=>{
  try { lazyLoadImagesIn(document); } catch(e){}
  try { if (window.table) table.on('draw', ()=> lazyLoadImagesIn(document)); } catch(e){}
});
</script>

<!-- Spectrogram modal removed: spectrogram is now an icon chip in Sound column -->

</body></html>
