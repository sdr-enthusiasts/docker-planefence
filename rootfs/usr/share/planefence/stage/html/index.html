<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Planefence</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/datatables.net-dt/css/jquery.dataTables.min.css">
  <!-- 1) CSS: row dim + small updater + dark zebra fix -->
  <style>
    /* ... keep your existing styles ... */

    /* Dim entire row while incomplete */
    tr.row-incomplete { color: var(--row-incomplete); }
    tr.row-incomplete a { color: inherit; }
    tr.row-incomplete .muted { color: inherit; opacity: .9; }

    /* Small “still updating” */
    .still-updating { font-size: 0.85em; }

    /* Override DataTables zebra to adapt to theme */
    table.dataTable.stripe tbody tr.odd,
    table.dataTable.display tbody tr.odd {
      background-color: var(--table-stripe);
    }
    /* Ensure even rows use base bg in both themes */
    table.dataTable tbody tr.even { background-color: var(--bg); }

    :root {
      color-scheme: light dark;
      /* height reserved for the top page header; table thead will stick beneath this */
      --header-height: 3.5rem;
      --bg: #ffffff;
      --fg: #111111;
      --muted: #666;
      --soft: #f5f5f5;
      --accent: #0b5fff;
      --danger-bg: #fff3f3;
      --danger-fg: #a40000;
      --row-incomplete: #6b6b6b;
      --chip-bg: #eee;
      --chip-fg: #222;
      --link: #0b5fff;
      --link-visited: #5a32a3;
      --table-stripe: #fafafa;
    }
    html.dark {
      --bg: #0f1115;
      --fg: #e6e6e6;
      --muted: #9aa0a6;
      --soft: #1a1d23;
      --accent: #6ca0ff;
      --danger-bg: #2a1212;
      --danger-fg: #ff8a8a;
      --row-incomplete: #9aa0a6;
      --chip-bg: #1f2430;
      --chip-fg: #e6e6e6;
      --link: #8fb1ff;
      --link-visited: #c6a6ff;
      --table-stripe: #151922;
    }

    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", sans-serif;
      background: var(--bg); color: var(--fg);
      line-height: 1.45;
    }
  header, footer { padding: .75rem 1rem; background: var(--soft); display: flex; align-items: center; gap: .75rem; }
  /* Keep header visible while scrolling */
  header { position: sticky; top: 0; z-index: 50; }
    header h1 { font-size: 1.1rem; margin: 0; font-weight: 600; }
    header .spacer { flex: 1; }
    button, .btn {
      background: transparent; border: 1px solid var(--muted); color: var(--fg); padding: .35rem .6rem; border-radius: .5rem; cursor: pointer;
    }
    button:hover { border-color: var(--fg); }
    a { color: var(--link); text-decoration: none; }
    a:visited { color: var(--link-visited); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .muted { color: var(--muted); }
    .status { margin-left: .5rem; }

    table.dataTable tbody tr:nth-child(odd) { background: var(--table-stripe); }
    table.dataTable thead th { white-space: nowrap; }
  /* Left-align all table headers for better readability */
  table.dataTable thead th, table#t thead th { text-align: left !important; }
  /* Constrain spectro column to thumbnail width so it doesn't expand */
  table.dataTable tbody td:nth-child(10), table.dataTable thead th:nth-child(10) { max-width: 56px; width: 56px; }
    /* Keep the table header visible while scrolling; it will sit just below the page header */
    table.dataTable thead th {
      position: sticky;
      top: var(--header-height);
      z-index: 40;
      background: var(--soft);
    }
    th, td { vertical-align: middle; }
    img.thumb { height: 56px; width: 56px; object-fit: cover; border-radius: .25rem; background: #0001; }
    .angle-img { height: 1em; vertical-align: -0.2em; margin-left: .25rem; }
  /* Position cell: give a little gap between coords and angle line */
  td.position-cell div { line-height: 1.2; }
  td.position-cell div + div { margin-top: 0.15rem; }
  /* Ensure angle image aligns center with the angle text */
  .angle-img { vertical-align: middle; height: 1em; margin-left: .35rem; }
    .chip { display: inline-flex; align-items: center; gap: .35rem; background: var(--chip-bg); color: var(--chip-fg); padding: .1rem .4rem; border-radius: .5rem; font-size: .85em; }
  .dot { display:none; }
    .danger { background: var(--danger-bg); color: var(--danger-fg); font-weight: 600; padding: 0 .25em; border-radius: .25em; }
  /* small SVG icons inside chips — make slightly larger for visibility */
  .chip svg { height: 1.25em; width: 1.25em; vertical-align: -0.15em; }
  .chip.muted { opacity: 0.8; }
  .badge-icon { height: 1.25em; width: 1.25em; object-fit: contain; vertical-align: -0.15em; }
  /* In dark mode, invert bitmap badges so dark lines become light */
  html.dark .badge-icon { filter: invert(1) brightness(2) contrast(1.2); }

  /* Chips (small badges) should use the chip background color in dark mode */
  html.dark .chip { background: var(--chip-bg); color: var(--chip-fg); }

  /* Modal preview for spectro images */
  .pf-modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.7); align-items: center; justify-content: center; z-index: 9999; }
  .pf-modal.open { display: flex; }
  .pf-modal .box { max-width: 90%; max-height: 90%; border-radius: .5rem; overflow: hidden; box-shadow: 0 8px 32px rgba(0,0,0,.6); }
  .pf-modal img { display: block; max-width: 100%; max-height: 100%; }

    .seen-incomplete { color: var(--row-incomplete); }

    .nowrap { white-space: nowrap; }
  /* Prevent Seen column from collapsing too narrow */
  /* DataTables places columns in the table header; target the third th (index starts at 1) */
  /* Keep Seen column readable but compact: single-line with ellipsis if too long */
  table.dataTable thead th:nth-child(3) { min-width: 8rem; max-width: 12rem; }
  table.dataTable tbody td:nth-child(3) { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  /* Highlight freshly-added rows briefly (soft fade-out) */
  .pf-new-row { animation: pf-fade 2.2s ease-out; background-color: rgba(108,169,255,0.18); }
  @keyframes pf-fade { 0% { background-color: rgba(108,169,255,0.28); } 100% { background-color: transparent; } }
  /* Ensure DataTables respects theme colors in dark mode and doesn't leave
    white cells/stripes. Use !important where DataTables default CSS is stronger. */
  table.dataTable { background: transparent; }
  table.dataTable tbody td, table.dataTable tbody tr { background: transparent; }
  /* Regular stripe rules (light and dark) */
  table.dataTable.stripe tbody tr.odd,
  table.dataTable.display tbody tr.odd { background-color: var(--table-stripe) !important; }
  table.dataTable tbody tr.even { background-color: var(--bg) !important; }
  /* Dark-mode specific enforcement to override DataTables' defaults */
  html.dark table.dataTable.stripe tbody tr.odd,
  html.dark table.dataTable.display tbody tr.odd { background-color: var(--table-stripe) !important; }
  html.dark table.dataTable tbody tr.even { background-color: var(--bg) !important; }
  /* Ensure individual cells (including the index cell span) don't show white */
  html.dark table.dataTable tbody td, html.dark table.dataTable tbody td * { background: transparent !important; color: var(--fg) !important; }
  /* DataTables sometimes wraps table body for scrolling; ensure those cells are covered */
  html.dark .dataTables_scrollBody table tbody tr td { background: transparent !important; }

  /* New-updates button default style (light mode) */
  #newUpdates { background: var(--chip-bg); color: var(--chip-fg); border-color: var(--muted); }
  /* Dark-mode adjustments for banner/button */
  html.dark #newUpdates { background: rgba(108,169,255,0.08); color: var(--fg); border-color: rgba(255,255,255,0.06); }

  /* Make the new-row highlight slightly different in dark mode */
  html.dark .pf-new-row { background-color: rgba(108,169,255,0.12) !important; }

  /* Row hover: ensure hover color is theme-aware (not white in dark mode) */
  /* Light mode hover: subtle darker tint */
  table.dataTable tbody tr:hover { background-color: rgba(0,0,0,0.03) !important; }
  table.dataTable tbody tr:hover td, table.dataTable tbody tr:hover td * { background: transparent !important; }
  /* Dark mode hover: subtle light tint */
  html.dark table.dataTable tbody tr:hover { background-color: rgba(255,255,255,0.03) !important; }
  html.dark table.dataTable tbody tr:hover td, html.dark table.dataTable tbody tr:hover td * { background: transparent !important; }
  </style>
</head>
<body>
  <header>
    <h1>Planefence</h1>
    <span class="status mono" id="progress">Loading…</span>
  <span class="status mono" id="lastupdate" style="margin-left: .5rem"></span>
  <span class="status mono" id="nextupdate" style="margin-left: .75rem">Next update: --</span>
    <div class="spacer"></div>
  <button id="themeToggle" title="Toggle dark/light">Dark</button>
  <button id="manualUpdate" title="Update now">Update</button>
  <button id="reload" title="Reload data">Reload</button>
  <button id="newUpdates" title="Show new updates" style="display:none; margin-left:.5rem;">New updates available</button>
  </header>

  <main style="padding: 0 1rem 1rem;">
    <div style="overflow:auto;">
      <table id="t" class="display compact stripe" style="width:100%;">
        <thead id="thead">
          <tr></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </main>

  <footer>
    <small class="muted">&copy; 2025</small>
  </footer>

  <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/datatables.net@2/js/dataTables.min.js"></script>

  <script>
  // -------- Config --------
  const cfg = {
    // Base URL where docroot images live (arrowXXX_day|night.png, thumbnails if hosted locally)
    // Ensure trailing slash. Change as needed, e.g., `${location.origin}/assets/`
    // mediaBase: location.origin + 'assets/',
    mediaBase: './assets/',
    // Temporary prefix to apply to noise/spectro/mp3 links (easy to change)
    // Set to empty string to disable. Useful when those files are served under a subpath like /noise/
    noisePrefix: './noise/',
  // Optional per-badge images (inlined as data URI so the page doesn't need external assets)
  // The UI will use CSS (html.dark .badge-icon) to invert/brighten bitmap/SVG badges in dark mode.
    noiseIcon: 'data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2216%22%20height%3D%2216%22%3E%3Ccircle%20cx%3D%228%22%20cy%3D%228%22%20r%3D%226%22%20fill%3D%22%230b5fff%22/%3E%3C/svg%3E',
  mp3Icon: 'data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2216%22%20height%3D%2216%22%3E%3Ccircle%20cx%3D%228%22%20cy%3D%228%22%20r%3D%226%22%20fill%3D%22%23ff8a00%22/%3E%3C/svg%3E',
    // Enable or disable the live stream reader and/or periodic polling. Set one or both to true as needed.
    enableStream: true,
    enablePoll: true,
    // Poll interval in seconds (used when enablePoll is true)
    pollIntervalSec: 60
  };

  // -------- Theme (dark/light) --------
  const THEME_KEY = 'pf-theme';
  function applyTheme(theme){
    const dark = theme === 'dark';
    document.documentElement.classList.toggle('dark', dark);
    const btn = document.getElementById('themeToggle');
    if (btn) btn.textContent = dark ? 'Light' : 'Dark';
    localStorage.setItem(THEME_KEY, theme);
  }
  function currentTheme(){
    const saved = localStorage.getItem(THEME_KEY);
    if (saved === 'dark' || saved === 'light') return saved;
    return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
  }
  applyTheme(currentTheme());
  document.getElementById('themeToggle')?.addEventListener('click', () => {
    applyTheme(document.documentElement.classList.contains('dark') ? 'light' : 'dark');
    if (window.table) window.table.rows().invalidate().draw(false); // refresh arrow assets
  });

  // -------- Helpers --------
  const prog = document.getElementById('progress');
  const lastUpdateEl = document.getElementById('lastupdate');
  const nextUpdateEl = document.getElementById('nextupdate');
  const theadRow = document.querySelector('#thead tr');
  const reloadBtn = document.getElementById('reload');
  reloadBtn?.addEventListener('click', () => location.reload());
  const manualUpdateBtn = document.getElementById('manualUpdate');
  // global button reference (element created in the header)
  const newUpdatesBtn = document.getElementById('newUpdates');

  function updateNewUpdatesBanner(){
    try {
      if (!newUpdatesBtn) return;
      const count = pendingNewIndices.size || 0;
      if (count > 0) {
        newUpdatesBtn.textContent = `New updates (${count})`;
      } else {
        newUpdatesBtn.textContent = 'New updates available';
        newUpdatesBtn.style.display = 'none';
      }
    } catch (e) { /* ignore */ }
  }

  // Next-poll tracking (timestamp in ms)
  let nextPollAt = null;
  let countdownTimerId = null;

  function startCountdown() {
    if (!nextUpdateEl) return;
    if (countdownTimerId) clearInterval(countdownTimerId);
    countdownTimerId = setInterval(()=>{
      if (!nextPollAt) { nextUpdateEl.textContent = 'Next update: --'; return; }
      const sec = Math.max(0, Math.round((nextPollAt - Date.now())/1000));
      nextUpdateEl.textContent = `Next update: ${sec}s`;
    }, 250);
  }

  function scheduleNextPoll(afterSec) {
    nextPollAt = Date.now() + (afterSec * 1000);
    startCountdown();
  }

  // Toggle countdown and manual update UI depending on polling configuration
  if (!cfg.enablePoll) {
    if (nextUpdateEl) nextUpdateEl.style.display = 'none';
    if (manualUpdateBtn) {
      manualUpdateBtn.disabled = true;
      manualUpdateBtn.title = 'Polling disabled';
    }
  } else {
    if (manualUpdateBtn) manualUpdateBtn.title = 'Trigger immediate update';
  }

  // Expose a global rowCount helper so non-streaming code (poller, UI) can query
  // current number of rows without depending on the streaming IIFE's local function.
  function rowCount() {
    try {
      if (!table) return 0;
      return Math.max(0, table.rows().count());
    } catch (e) { return 0; }
  }

  function fmtInt(s){ const n = Number(s); return Number.isFinite(n)? n : null; }
  function safe(s){ return String(s ?? ""); }
  function isHttp(u){ return typeof u === 'string' && /^https?:\/\//i.test(u); }
  function toFixed4(n){ const x = Number(n); return Number.isFinite(x)? x.toFixed(4) : ""; }
  function degBucket10(n){
    const num = Number(n);
    if (!Number.isFinite(num)) return null;
    const rounded = Math.round(num);
    let b = Math.round(rounded/10)*10;
    b = ((b % 360) + 360) % 360;
    if (b === 360) b = 0;
    return b;
  }
  function angleAssetName(deg, dark){
    const b = degBucket10(deg);
    if (b==null) return null;
    return `arrow${b}_${dark? 'night':'day'}.png`;
  }

  // 3) Seen rendering: two lines, small “still updating”, no “at”
  function formatSeen(secStr, completeFlag, preferTs){
    const s = Number(preferTs ?? secStr);
    if (!Number.isFinite(s)) return "";
    const nowMs = Date.now();
    const tsMs = s * 1000;
    const diffSec = Math.max(0, Math.floor((nowMs - tsMs)/1000));
    const rel = diffSec < 60 ? `${diffSec}s ago`
          : diffSec < 3600 ? `${Math.floor(diffSec/60)}m ago`
          : `${Math.floor(diffSec/3600)}h ago`;

    const dt = new Date(tsMs);
    // Use 24-hour clock (hour12: false) with two-digit hour for consistency
    const timeFmt = new Intl.DateTimeFormat(undefined, {
      hour: '2-digit', minute: '2-digit', timeZoneName: 'short', hour12: false
    });
    const timeStr = timeFmt.format(dt);

    const today = new Date();
    const sameDay = dt.getFullYear()===today.getFullYear()
                && dt.getMonth()===today.getMonth()
                && dt.getDate()===today.getDate();
    const dateStr = sameDay ? "" : new Intl.DateTimeFormat(undefined, {
      year:'numeric', month:'short', day:'numeric'
    }).format(dt);

    const updating = (String(completeFlag) !== 'true')
      ? `<div class="still-updating">· still updating</div>` : "";

    // Line 1: relative; Line 2: time (+ date if not today)
    return `<div class="mono">${rel}</div><div class="mono">${timeStr}${dateStr ? ' · ' + dateStr : ''}</div>${updating}`;
  }


  function hasSound(r){
    return r['sound:peak'] || r['sound:loudness'] || r['sound:color'] || r['noisegraph:link'];
  }
  function hasNotifications(r){
    return r['discord:link'] || r['bsky:link'] || r['telegram:link'] || r['mqtt:notified'];
  }

  // Normalize per-row values into typed fields so rendering is consistent
  function normalizeRow(r) {
    if (!r || typeof r !== 'object') return r;
    const out = Object.assign({}, r);
    // Coerce boolean-like flags
    const truthy = v => {
      if (v === true || v === 1) return true;
      const s = String(v || '').toLowerCase();
      return s === 'true' || s === '1' || s === 'yes';
    };
    out.HASNOISE = truthy(out.HASNOISE || out.hasOwnProperty('HASNOISE') && out.HASNOISE);
    out.HASIMAGES = truthy(out.HASIMAGES || out.hasOwnProperty('HASIMAGES') && out.HASIMAGES);
    out.HASROUTE = truthy(out.HASROUTE || out.hasOwnProperty('HASROUTE') && out.HASROUTE);
    out.complete = String(out.complete) === 'true' || out.complete === true;
    // Coerce notified flags
    out['discord:notified'] = truthy(out['discord:notified']);
    out['bsky:notified'] = truthy(out['bsky:notified']);
    out['telegram:notified'] = truthy(out['telegram:notified']);
    out['mqtt:notified'] = truthy(out['mqtt:notified']);
    // Numeric conversions
    out.index = Number(out.index);
    out['time:lastseen'] = Number(out['time:lastseen']) || Number(out['time:firstseen']) || 0;
    out['time:firstseen'] = Number(out['time:firstseen']) || 0;
    out['time:time_at_mindist'] = Number(out['time:time_at_mindist']) || 0;
    out['sound:peak'] = out['sound:peak'] !== '' ? out['sound:peak'] : null;
    out['sound:loudness'] = out['sound:loudness'] !== '' ? out['sound:loudness'] : null;
    return out;
  }

  // Small inline SVG icon helpers
  function iconNoise(){ return `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 12h3l3-6v12l-3-6H3z" fill="currentColor"/></svg>` }
  function iconMp3(){ return `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 3v10.55A4 4 0 1 0 14 17V7h4V3h-6z" fill="currentColor"/></svg>` }
  function iconSpectro(){ return `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="3" y="6" width="18" height="12" rx="2" stroke="currentColor" fill="none"/><path d="M6 12h1v2H6v-2zm3-2h1v4H9v-4zm3-3h1v7h-1V7zm3 1h1v6h-1V8zm3-2h1v8h-1V6z" fill="currentColor"/></svg>` }

  // -------- Columns definition --------
  const viewCols = [
    { key:"idx", title:"#", width:"4%" },
    { key:"thumb", title:"", width:"6%" },
  { key:"when", title:"Time when closest" },
    { key:"aircraft", title:"Aircraft", width:"22%" },
  // Route column removed; route will be shown in Aircraft column after callsign
  // Position column slightly narrower (~70% of previous). Previous was 16%.
  { key:"position", title:"Position", width:"11%" },
    // Combined Alt/Spd column: both values shown on separate lines inside the same cell
  // Make Alt/Spd (speed) about 50% of previous width
  { key:"altspd", title:"Alt / Spd", width:"7%" },
    { key:"trk", title:"Track", width:"7%" },
  { key:"squawk", title:"Squawk", width:"8%" },
  { key:"sound", title:"Sound", width:"10%" },
  // Spectro column should match the spectro thumbnail size (56px)
  { key:"spectro", title:"Spectro", width:"56px" },
    { key:"notify", title:"Notifications", width:"12%" }
  ];

  let table = null;
  // Map of index -> DataTables row API for fast incremental updates
  const rowByIndex = new Map();
  // Map of index -> consecutive-miss count used to implement a grace period before purging
  const missingCounts = new Map();
  // Track indices added since last user-visible redraw. Used to highlight new rows.
  const pendingNewIndices = new Set();

  // 2) DataTables init: numeric sort for idx, keep Seen desc
 function buildHeader(){
  theadRow.innerHTML = "";
  for (const c of viewCols){
    const th = document.createElement('th');
    th.textContent = c.title;
    if (c.width) th.style.width = c.width;
    theadRow.appendChild(th);
  }

  // Replace Alt / Spd header content with clickable sort controls for numeric sorting
  try {
    const altIdx = viewCols.findIndex(v => v.key === 'altspd');
    if (altIdx >= 0) {
      const th = theadRow.children[altIdx];
      if (th) {
        th.innerHTML = `Alt / Spd <span style="margin-left:.5rem; font-size:0.85em; color:var(--muted);">` +
          `<a href="#" id="sortAlt" style="margin-right:.4rem;">Alt</a>` +
          `<a href="#" id="sortSpd">Spd</a></span>`;
        // Wire click handlers which compute the Alt/Spd column index at runtime,
        // copy the chosen numeric attribute into data-order, and toggle
        // ascending/descending on each click.
        setTimeout(()=>{
          const aAlt = document.getElementById('sortAlt');
          const aSpd = document.getElementById('sortSpd');
          // determine column index dynamically from the header cell position
          const colIdx = (typeof th?.cellIndex === 'number') ? th.cellIndex : altIdx;

          const copyAttrToDataOrder = (attrName) => {
            try {
              const nodes = table.column(colIdx, {order:'applied'}).nodes();
              const arr = nodes.toArray ? nodes.toArray() : Array.from(nodes);
              for (const td of arr) {
                try {
                  const inner = td.querySelector && (td.querySelector(`[data-${attrName}]`) || td.querySelector('[data-order]')) || td;
                  if (inner && inner.setAttribute) {
                    const v = inner.getAttribute && inner.getAttribute(`data-${attrName}`);
                    if (v != null) inner.setAttribute('data-order', v);
                  }
                } catch(e) { /* per-cell ignore */ }
              }
            } catch(e) { console.warn('copyAttrToDataOrder failed', e); }
          };

          if (aAlt) aAlt.addEventListener('click', (ev)=>{
            ev.preventDefault();
            // Toggle direction state stored on the TH element
            try {
              const prev = th.dataset.altDir || 'desc';
              const dir = prev === 'asc' ? 'desc' : 'asc';
              th.dataset.altDir = dir;
              copyAttrToDataOrder('order-alt');
              table.settings()[0].aoColumns[colIdx].orderDataType = 'dom-data-order';
              table.order([[colIdx, dir]]).draw(false);
            } catch(e) { console.warn('sortAlt failed', e); }
          });

          if (aSpd) aSpd.addEventListener('click', (ev)=>{
            ev.preventDefault();
            try {
              const prev = th.dataset.spdDir || 'desc';
              const dir = prev === 'asc' ? 'desc' : 'asc';
              th.dataset.spdDir = dir;
              copyAttrToDataOrder('order-spd');
              table.settings()[0].aoColumns[colIdx].orderDataType = 'dom-data-order';
              table.order([[colIdx, dir]]).draw(false);
            } catch(e) { console.warn('sortSpd failed', e); }
          });
        }, 0);
      }
    }
  } catch (e) { /* ignore header wiring errors */ }

  // Create DataTable and capture API
  // Ordering plugin: read numeric value from an inner element's data-order attribute
  // and use that as the sort key for the column. This ensures the index column
  // sorts by the numeric index we embed in the rendered HTML.
  jQuery.fn.dataTable.ext.order['dom-data-order'] = function(settings, col) {
    return this.api().column(col, {order:'index'}).nodes().map(function(td){
      try {
        // If DataTables gives us an Element, query inside it
        if (td && td.querySelector) {
          const el = td.querySelector('[data-order]');
          if (el) {
            const v = el.getAttribute('data-order');
            const n = Number(v);
            return Number.isFinite(n) ? n : v;
          }
        }
        // Sometimes with deferRender DataTables may return a plain string for the cell.
        // Handle that by parsing the HTML string for data-order instead of using querySelector.
        if (typeof td === 'string') {
          const m = td.match(/data-order="(-?\d+)"/);
          if (m) return Number(m[1]);
        }
      } catch (e) { /* ignore */ }
      // fallback: parse numeric from text content (covers both Element and string)
      const txt = (td && td.textContent) ? td.textContent.trim() : (typeof td === 'string' ? td : '');
      const n2 = Number(txt.replace(/[^0-9.\-]/g,''));
      return Number.isFinite(n2) ? n2 : txt;
    });
  };

  // Ordering plugin for Altitude (reads numeric value from data-order-alt)
  jQuery.fn.dataTable.ext.order['dom-data-order-alt'] = function(settings, col) {
    return this.api().column(col, {order:'index'}).nodes().map(function(td){
      try {
        if (td && td.querySelector) {
          const el = td.querySelector('[data-order-alt]');
          if (el) {
            const v = el.getAttribute('data-order-alt');
            const n = Number(v);
            return Number.isFinite(n) ? n : v;
          }
        }
        if (typeof td === 'string') {
          const m = td.match(/data-order-alt="(-?\d+)"/);
          if (m) return Number(m[1]);
        }
      } catch (e) { /* ignore */ }
      const txt = (td && td.textContent) ? td.textContent.trim() : (typeof td === 'string' ? td : '');
      const n2 = Number(txt.replace(/[^0-9.\-]/g,''));
      return Number.isFinite(n2) ? n2 : txt;
    });
  };

  // Ordering plugin for Speed (reads numeric value from data-order-spd)
  jQuery.fn.dataTable.ext.order['dom-data-order-spd'] = function(settings, col) {
    return this.api().column(col, {order:'index'}).nodes().map(function(td){
      try {
        if (td && td.querySelector) {
          const el = td.querySelector('[data-order-spd]');
          if (el) {
            const v = el.getAttribute('data-order-spd');
            const n = Number(v);
            return Number.isFinite(n) ? n : v;
          }
        }
        if (typeof td === 'string') {
          const m = td.match(/data-order-spd="(-?\d+)"/);
          if (m) return Number(m[1]);
        }
      } catch (e) { /* ignore */ }
      const txt = (td && td.textContent) ? td.textContent.trim() : (typeof td === 'string' ? td : '');
      const n2 = Number(txt.replace(/[^0-9.\-]/g,''));
      return Number.isFinite(n2) ? n2 : txt;
    });
  };

  const api = $('#t').DataTable({
    // Disable deferRender to ensure cells/nodes exist when we need to parse
    // data-order attributes and to avoid string-only cell representations.
    deferRender: false,
    pageLength: 25,
    responsive: true,
  // Default ordering: newest (highest index) first
  order: [[0, 'desc']],
    columns: viewCols.map(_ => ({ title: _.title })),
    columnDefs: [
      // Use our dom-data-order plugin for column 0 (index) so sorting honors
      // the numeric value placed in the cell's data-order attribute.
      { targets: 0, orderDataType: 'dom-data-order' },
      // For Alt/Spd column (index 5 in viewCols), allow numeric ordering by
      // altitude or by speed via our custom orderDataType plugins. We'll
      // wire header click handlers to call the appropriate ordering.
      { targets: 5, orderDataType: 'dom-data-order-alt' },
      { targets: "_all", render: (data)=>data }
    ],
    createdRow: function(row, data){
      // Mark rows that are still updating
      if ((data?.[2] || '').includes('still-updating')) {
        row.classList.add('row-incomplete');
      } else {
        row.classList.remove('row-incomplete');
      }

      // Try to extract numeric index from the first-cell HTML and stash it on the TR.
      try {
        const first = data && data[0] ? String(data[0]) : '';
        const m = first.match(/data-order="(-?\d+)"/);
        if (m) {
          const id = Number(m[1]);
          row.dataset.idx = id;
          // If the table API is available, store the API row reference for fast lookup
          if (table) rowByIndex.set(id, table.row(row));
        }
      } catch (e) { /* ignore */ }
    }
  });

  // Store globally if you need it
  table = api;
  window.table = api;

  // Preserve top row when the page length changes: capture current display start
  // and restore it after DataTables applies the new length. This keeps the
  // same top row visible and lets additional rows appear below it.
  try {
    const lenSel = document.querySelector('#t_length select');
    if (lenSel) {
      let anchorIdx = null;
      // On focus store the numeric index value from the first logical row using DOM if available.
      // Using DOM is more robust now that deferRender is disabled; fallback to column data if needed.
      lenSel.addEventListener('focus', ()=>{
        try {
          const info = table.page ? table.page.info() : null;
          if (!info) return;
          const start = info.start || 0;
          // Prefer reading from the visible DOM row if present
          const tr = document.querySelector('#t tbody tr');
          if (tr && tr.dataset && tr.dataset.idx) {
            anchorIdx = Number(tr.dataset.idx);
            return;
          }
          // Fallback: use column data
          const colData = table.column(0, {order: 'applied'}).data();
          if (!colData || colData.length === 0) { anchorIdx = null; return; }
          const cell = String(colData[start] || '');
          const m = cell.match(/data-order="(-?\d+)"/);
          anchorIdx = m ? Number(m[1]) : null;
        } catch (e) { anchorIdx = null; }
      });

      lenSel.addEventListener('change', ()=>{
        try {
          if (anchorIdx == null) return;
          // After the change, give DataTables a tick to reflow, then try to locate the
          // same anchor index in the newly ordered column data. We aggressively
          // invalidate rows to ensure data() returns DOM/HTML we can parse.
          setTimeout(()=>{
            try {
              try { table.rows().invalidate(); } catch(e) { /* ignore */ }
              const col = table.column(0, {order: 'applied'});
              const colDataArr = col.data().toArray ? col.data().toArray() : Array.from(col.data());
              const ids = colDataArr.map(c => {
                const s = String(c || '');
                const m = s.match(/data-order="(-?\d+)"/);
                return m ? Number(m[1]) : null;
              });
              const pos = ids.indexOf(Number(anchorIdx));
              if (pos >= 0) {
                const newPage = Math.floor(pos / table.page.len());
                table.page(newPage).draw(false);
              } else {
                // Fallback: go to first page so user sees newest rows
                table.page('first').draw(false);
              }
            } catch (e) { console.warn('anchor restore failed', e); table.page('first').draw(false); }
            anchorIdx = null;
          }, 50);
        } catch (e) { anchorIdx = null; }
      });
    }
  } catch(e) { /* ignore */ }

  // Populate rowByIndex for any rows DataTables already created during init
  try {
    api.rows().every(function(){
      const tr = this.node();
      if (!tr) return;
      const d = this.data();
      const first = d && d[0] ? String(d[0]) : '';
      const m = first.match(/data-order="(-?\d+)"/);
      if (m) {
        const id = Number(m[1]);
        tr.dataset.idx = id;
        rowByIndex.set(id, api.row(tr));
      }
    });
  } catch (e) { /* ignore */ }

  // Bind draw handler AFTER api exists
  api.on('draw', function(){
    // Only rows in the current page are guaranteed to have nodes
    api.rows({ page: 'current' }).every(function(){
      const tr = this.node();
      if (!tr) return; // node may be null when not in DOM
      const seenCell = (this.data()?.[2] || '');
      if (seenCell.includes('still-updating')) tr.classList.add('row-incomplete');
      else tr.classList.remove('row-incomplete');
    });
  });
}

// Helper: expand comma-separated discord links in the Notifications column.
// If a cell contains a single anchor whose href contains commas (multiple URLs),
// or if the cell has a data-discord-links attribute with comma-separated URLs,
// create an anchor for each URL labeled 'Discord'. This runs after table draws
// so it will affect both streaming and polled updates.
function expandDiscordLinksInNotifications() {
  try {
    if (!table) return;
    // Find all cells in the Notifications column (last column index)
    const notifColIdx = viewCols.findIndex(c => c.key === 'notify');
    if (notifColIdx === -1) return;
    // For each visible row cell in the column
    table.column(notifColIdx, {page: 'current'}).nodes().each(function(td){
      try {
        const cell = td instanceof Element ? td : (td && td.node) ? td.node : null;
        if (!cell) return;

        // First, check for a data attribute with comma-separated links
        const dataVal = cell.getAttribute && cell.getAttribute('data-discord-links');
        let links = null;
        if (dataVal) {
          links = dataVal.split(',').map(s => s.trim()).filter(Boolean);
        } else {
          // Otherwise, if there's exactly one anchor, look at its raw attribute value
          const anchors = cell.querySelectorAll && cell.querySelectorAll('a');
          if (anchors && anchors.length === 1) {
            const a = anchors[0];
            const rawHref = a.getAttribute && a.getAttribute('href');
            if (rawHref && rawHref.includes(',')) {
              links = rawHref.split(',').map(s => s.trim()).filter(Boolean);
            }
          }
          // If no anchors or single-anchor case didn't detect commas, also try plain text (comma-separated URLs)
          if (!links) {
            const txt = (cell.textContent || '').trim();
            if (txt && txt.includes(',')) {
              // Split and keep probable URLs (simple heuristic: starts with http or /)
              const candidates = txt.split(',').map(s => s.trim()).filter(Boolean);
              const probable = candidates.filter(s => /^https?:\/\//i.test(s) || s.startsWith('/'));
              if (probable.length > 0) links = probable;
            }
          }
        }

        if (!links || links.length <= 1) return; // nothing to do

        // Clear existing content and append an anchor per link, separated by middot
        cell.innerHTML = '';
        links.forEach((lnk, i) => {
          const a = document.createElement('a');
          a.href = lnk;
          a.target = '_blank';
          a.rel = 'noopener';
          a.textContent = 'Discord';
          cell.appendChild(a);
          if (i !== links.length - 1) cell.appendChild(document.createTextNode(' · '));
        });
      } catch (e) { /* per-cell ignore */ }
    });
  } catch (e) { console.warn('expandDiscordLinksInNotifications failed', e); }
}

// Hook into DataTables draw event so newly-rendered pages have expanded links
if (typeof table !== 'undefined' && table) {
  table.on && table.on('draw', expandDiscordLinksInNotifications);
}

// Also call once after initial setup if table exists
setTimeout(()=> expandDiscordLinksInNotifications(), 150);

// 5) Render row with row class + position split link + numeric idx data source
function renderRow(r) {
  const idx = fmtInt(r.index) ?? safe(r.index);
  const idxVal = fmtInt(r.index);
  const idxCell = idxVal != null
    ? `<span class="mono" data-order="${idxVal}">${idxVal}</span>`
    : `<span class="mono">${safe(r.index)}</span>`;

  // Seen
  const lastSeen = r["time:lastseen"] || "";
  const firstSeen = r["time:firstseen"] || "";
  const atMindist = r["time:time_at_mindist"] || "";
  const whenHtml = (atMindist || lastSeen || firstSeen)
    ? formatSeen(lastSeen || firstSeen, r.complete, atMindist || lastSeen || firstSeen)
    : "";

  const icao = safe(r.icao);
  const tail = safe(r.tail);
  const cs = safe(r.callsign);
  const typ = safe(r.type);
  const owner = safe(r.owner);
  const faalink = safe(r["link:faa"] || r["link:fa"]);
  const ownerHtml = owner ? (isHttp(faalink) ? `<a href="${faalink}" target="_blank" rel="noopener">${owner}</a>` : owner) : "";
  const op = ownerHtml ? `<span class="muted">${ownerHtml}</span>` : "";
  // If a type is present, render it as a Skybrary link (lowercased). Encode the path component to be safe.
  const typHtml = typ ? (() => {
    try {
      const typePath = encodeURIComponent(String(typ).toLowerCase());
      const url = `https://skybrary.aero/aircraft/${typePath}`;
      return `<a href="${url}" target="_blank" rel="noopener">${typ}</a>`;
    } catch (e) { return typ; }
  })() : '';
  const route = safe(r.route);
  // Show route after callsign in the same Aircraft cell, unless it's 'n/a'
  const routeHtml = (route && route.toLowerCase() !== 'n/a') ? ` · ${route}` : '';
  const aircraft = `
    <div class="mono">${cs || icao}${routeHtml}</div>
    <div>${tail ? tail+' · ' : ''}${typHtml || typ}${op? ' · '+op : ''}</div>
  `.trim();

  // Position: coords link only; angle outside link; add N/E
  const lat = r.lat, lon = r.lon;
  const coordText = formatLatLon(lat, lon);
  const map = safe(r["link:map"]);
  const angleDegRaw = Number(r["angle:value"]);
  const angleDegInt = Number.isFinite(angleDegRaw) ? Math.round(angleDegRaw) : null;
  const angleName = r["angle:name"] ? ` (${safe(r["angle:name"])})` : "";
  const angleStr = angleDegInt != null ? `${angleDegInt}°${angleName}` : "";
  const angleImg = (() => {
    const a = angleAssetName(angleDegRaw, document.documentElement.classList.contains('dark'));
    return a ? `<img class="angle-img" alt="" src="${cfg.mediaBase}${a}">` : "";
  })();
  const coordsHtml = coordText
    ? (map ? `<a href="${map}" target="_blank" rel="noopener">${coordText}</a>` : coordText)
    : "";
  // Put coords on first line and angle (text + image) on a separate second line within the same cell.
  const angleCombined = [angleStr, angleImg].filter(Boolean).join('');
  const positionInner = [coordsHtml ? `<div>${coordsHtml}</div>` : '', angleCombined ? `<div>${angleCombined}</div>` : ''].filter(Boolean).join('');
  const position = positionInner ? `<div class="position-cell">${positionInner}</div>` : "";

  const altRaw = Number(r["altitude:value"]);
  const altVal = Number.isFinite(altRaw) ? `${safe(r["altitude:value"])} ${safe(r["altitude:unit"] || "ft")}` : "";
  const spdNum = fmtInt(r["groundspeed:value"]);
  const spdUnit = safe(r["groundspeed:unit"] || "kt");
  const spdVal = spdNum != null ? `${spdNum} ${spdUnit}` : "";
  // Choose numeric ordering priority: altitude (feet) if present, else groundspeed (kt), else 0
  const numericOrder = Number.isFinite(altRaw) ? altRaw : (spdNum != null ? spdNum : 0);
  // Combine altitude and speed into a single cell (altitude on first line, speed on second if present)
  const altspdInner = [altVal ? `<div class="mono">${altVal}</div>` : '', spdVal ? `<div class="mono">${spdVal}</div>` : ''].filter(Boolean).join('');
  // Include separate numeric attributes for altitude and speed to allow
  // independent numeric sorting when a user clicks Alt or Spd in the header.
  const altAttr = Number.isFinite(altRaw) ? altRaw : '';
  const spdAttr = spdNum != null ? spdNum : '';
  const altspd = `<div data-order-alt="${altAttr}" data-order-spd="${spdAttr}">${altspdInner}</div>`;

  const trackDegRaw = Number(r["track:value"]);
  const trackDegInt = Number.isFinite(trackDegRaw) ? Math.round(trackDegRaw) : null;
  const trackName = r["track:name"] ? ` (${safe(r["track:name"])})` : "";
  const trkStr = trackDegInt != null ? `${trackDegInt}°${trackName}` : "";
  const trkImg = (() => {
    const a = angleAssetName(trackDegRaw, document.documentElement.classList.contains('dark'));
    return a ? `<img class="angle-img" alt="" src="${cfg.mediaBase}${a}">` : "";
  })();
  const trk = trkStr ? `${trkStr}${trkImg}` : "";

  const thumbUrl = r["image:thumblink"];
  const thumbEl = isHttp(thumbUrl) ? `<img class="thumb" src="${thumbUrl.replace(/"/g,'&quot;')}" alt="thumb">` : "";

  const links = [];
  const photo = safe(r["image:link"]);
  const spectro = safe(r["spectro:link"]);
  const noise = safe(r["noisegraph:link"]);
  const mp3 = safe(r["mp3:link"]);
  // Photo is shown as thumbnail; remove it from Links list to avoid duplication
  // We'll render spectro as a thumbnail in the Spectro column and noise/mp3 as badges in the Sound column.

  // Spectro cell: if a spectro link exists, show it as a small thumbnail (same height as main thumb)
  // Note: the link may be relative (we applied cfg.noisePrefix earlier), so allow non-http URLs
  let spectroCell = '';
  if (spectro) {
    const sUrl = safe(spectro);
    // Thumbnail opens modal preview instead of linking directly
    spectroCell = `<a href="#" class="spectro-thumb" data-src="${sUrl}" rel="noopener"><img src="${sUrl}" alt="spectro" style="height:56px;width:56px;object-fit:cover;border-radius:.25rem"></a>`;
  }

  // Notifications: show link if available, otherwise show a notified badge when the *_notified flag is true
  const notifyLinks = [];
  const discordLink = r["discord:link"];
  const bskyLink = r["bsky:link"];
  const telegramLink = r["telegram:link"];
  const mqttFlag = r["mqtt:notified"];
  // Treat several textual representations as truthy
  const truthy = v => {
    if (v === true || v === 1) return true;
    const s = String(v || '').toLowerCase();
    return s === 'true' || s === '1' || s === 'yes';
  };
  const discordNotified = truthy(r["discord:notified"]);
  const bskyNotified = truthy(r["bsky:notified"]);
  const telegramNotified = truthy(r["telegram:notified"]);
  const mqttNotified = truthy(mqttFlag);

  if (discordLink) notifyLinks.push(`<a href="${safe(discordLink)}" target="_blank" rel="noopener">Discord</a>`);
  else if (discordNotified) notifyLinks.push(`<span class="chip muted">Discord</span>`);

  if (bskyLink) notifyLinks.push(`<a href="${safe(bskyLink)}" target="_blank" rel="noopener">Bluesky</a>`);
  else if (bskyNotified) notifyLinks.push(`<span class="chip muted">Bluesky</span>`);

  if (telegramLink) notifyLinks.push(`<a href="${safe(telegramLink)}" target="_blank" rel="noopener">Telegram</a>`);
  else if (telegramNotified) notifyLinks.push(`<span class="chip muted">Telegram</span>`);

  if (mqttNotified) notifyLinks.push(`<span class="chip muted">MQTT</span>`);

  // Sound column: show a small chip with peak/loud info, and separate small clickable badges for noisegraph and mp3 if present.
  let sound = "";
  const parts = [];
  if (hasSound(r)) {
  const peak = r["sound:peak"] ? `Peak ${safe(r["sound:peak"]) } dbFS` : "";
  const loud = r["sound:loudness"] ? `Loud ${safe(r["sound:loudness"]) } dB` : "";
  const dot = r["sound:color"] ? `<span class="dot" style="background:${safe(r["sound:color"]) }"></span>` : "";
    const inner = `<span class="chip">${dot}${[peak, loud].filter(Boolean).join(' · ')}</span>`;
    parts.push(inner);
  }
  // Noisegraph badge
  if (noise) {
    const nUrl = safe(noise);
    // Use configured image badge when available; CSS will invert it in dark mode
    const nIcon = cfg.noiseIcon;
    const nBadge = nIcon ? `<img class="badge-icon" src="${nIcon}" alt="noise">` : iconNoise();
    parts.push(`<a class="chip" href="${nUrl}" target="_blank" rel="noopener">${nBadge}</a>`);
  }
  // MP3 badge
  if (mp3) {
    const mUrl = safe(mp3);
    const mIcon = cfg.mp3Icon;
    const mBadge = mIcon ? `<img class="badge-icon" src="${mIcon}" alt="mp3">` : iconMp3();
    parts.push(`<a class="chip" href="${mUrl}" target="_blank" rel="noopener">${mBadge}</a>`);
  }
  sound = parts.join(' ');

  const squawkVal = safe(r["squawk:value"]);
  const squawkDesc = r["squawk:description"] ? ` <span class="muted">(${safe(r["squawk:description"])})</span>` : "";
  const isEmerg = squawkVal === "7500" || squawkVal === "7600" || squawkVal === "7700";
  const squawk = squawkVal ? `<span class="${isEmerg ? 'danger' : ''} mono">${squawkVal}</span>${squawkDesc}` : "";

  return {
    row: [
    `${idxCell}`,
    `${thumbEl}`,
    `${whenHtml}`,
  `${aircraft}`,
  `${position}`,
  `${altspd}`,
    `${trk}`,
    `${squawk}`,
    `${sound}`,
  `${spectroCell}`,
    `${notifyLinks.join(' · ')}`
  ],
    incomplete: String(r.complete) !== 'true'
  };
}


// 6) Prepend newest-first during streaming and apply row class
function addRow(r){
  const rendered = renderRow(r);
  // Use row.add() + draw order OR unshift: DataTables APIs don’t support unshift directly,
  // but we can insert at top by drawing with order and using row.add, then re-order.
  // Simpler: add, then immediately order by Seen desc (already set) and draw.
  const apiRow = table.row.add(rendered.row);
  // Try to extract the index from the rendered HTML and register it in our map.
  try {
    const first = rendered.row && rendered.row[0] ? String(rendered.row[0]) : '';
    const m = first.match(/data-order="(-?\d+)"/);
    if (m) {
      const id = Number(m[1]);
      const node = apiRow.node();
      if (node) node.dataset.idx = id;
      rowByIndex.set(id, apiRow);
    }
  } catch (e) { /* ignore */ }
  return apiRow;
}

  // 4) Position: link only coords, add N/E; angle outside link
  function formatLatLon(lat, lon){
    const latNum = Number(lat);
    const lonNum = Number(lon);
    if (!Number.isFinite(latNum) || !Number.isFinite(lonNum)) return "";
    return `${toFixed4(latNum)}&deg; N, ${toFixed4(lonNum)}&deg; E`;
  }


  // Build header immediately (schema not needed since columns are curated)
  if (!table) buildHeader();

  // If enabled, run the streaming reader (ReadableStream) to ingest rows as they arrive
  if (cfg.enableStream) {
    (async function(){
      try {
        const resp = await fetch('./cgi/pf-stream.sh', { cache: 'no-store' });
        if (!resp.ok || !resp.body) { prog.textContent = 'Stream failed'; return; }

        const reader = resp.body.getReader();
        const dec = new TextDecoder();
        let buf = '';
        let added = 0;
        let seenHeader = false;
        let streamGlobals = {};

        // Normalize/coerce globals into useful JS types
        function setStreamGlobals(g) {
          streamGlobals = {};
          if (!g || typeof g !== 'object') return;
          // Booleans stored as strings "true"/"1"/"yes"
          const truthy = v => {
            if (v === true || v === 1) return true;
            if (typeof v !== 'string') return false;
            const s = v.toLowerCase();
            return s === 'true' || s === '1' || s === 'yes';
          };
          streamGlobals.HASNOISE = truthy(g.HASNOISE || g.hasOwnProperty('HASNOISE') && g.HASNOISE);
          streamGlobals.HASIMAGES = truthy(g.HASIMAGES || g.hasOwnProperty('HASIMAGES') && g.HASIMAGES);
          streamGlobals.HASROUTE = truthy(g.HASROUTE || g.hasOwnProperty('HASROUTE') && g.HASROUTE);
          streamGlobals.LASTUPDATE = Number(g.LASTUPDATE) || 0;
          streamGlobals.maxindex = Number(g.maxindex) || 0;
          // Preserve any other keys as-is
          for (const k of Object.keys(g)) if (!(k in streamGlobals)) streamGlobals[k] = g[k];
        }

        // Redraw helper: if the user is on the first page, fully redraw so new
        // records immediately appear at the top. If the user is elsewhere, show
        // a "New updates available" banner instead and don't change their page.
        const redraw = (forceFull=false)=> {
          try {
            if (!table) return;
            const info = table.page ? table.page.info() : null;
            const onFirst = info && info.page === 0;
            if (forceFull || onFirst) {
              // Full redraw to ensure rows appear in the expected order and
              // DataTables re-renders the page 0 contents.
              table.order([[0,'desc']]).page('first').draw(false);
              // After drawing, highlight any newly added rows registered in pendingNewIndices
              highlightPendingNewRows();
              // hide banner when we show the new rows
              if (newUpdatesBtn) newUpdatesBtn.style.display = 'none';
            } else {
              // Not on first page: reveal banner so user can choose to jump.
              if (newUpdatesBtn) {
                newUpdatesBtn.style.display = 'inline-block';
                updateNewUpdatesBanner();
              }
              // Still update internal ordering/data so rows are present when the user returns
              table.order([[0,'desc']]).draw(false);
            }
          } catch (e) { console.error('redraw error', e); }
        };

        // When called after a table draw, highlight rows whose numeric idx is in pendingNewIndices
        function highlightPendingNewRows(){
          try {
            if (!table) return;
            // Look for TRs with dataset.idx matching our pending set
            pendingNewIndices.forEach(idx => {
              const tr = document.querySelector(`tr[data-idx="${idx}"]`);
              if (tr) {
                tr.classList.add('pf-new-row');
                // Remove highlight after 2.2s (matches animation duration)
                setTimeout(()=> tr.classList.remove('pf-new-row'), 2200);
              }
            });
            // Clear pending indices after attempting highlight
            pendingNewIndices.clear();
          } catch (e) { /* ignore */ }
        }

        // Use global rowCount() helper; do not shadow it here.

        while (true) {
          const {value, done} = await reader.read();
          if (done) break;
          buf += dec.decode(value, {stream:true});
          let nl;
          while ((nl = buf.indexOf('\n')) >= 0) {
            const line = buf.slice(0, nl); buf = buf.slice(nl+1);
            if (!line.trim()) continue;
            let obj;
            try { obj = JSON.parse(line); } catch(e){ console.error('Bad JSON:', e, line); continue; }
            // The stream may emit a globals object first, then a schema (__columns), then rows.
            if (obj && obj.__globals) {
              // Store and coerce globals
              setStreamGlobals(obj.__globals || {});
              // Update LASTUPDATE in header if present in globals (coerced)
              if (streamGlobals.LASTUPDATE && Number.isFinite(streamGlobals.LASTUPDATE) && streamGlobals.LASTUPDATE > 0) {
                const dt = new Date(streamGlobals.LASTUPDATE * 1000);
                const hh = String(dt.getHours()).padStart(2,'0');
                const mm = String(dt.getMinutes()).padStart(2,'0');
                lastUpdateEl.textContent = `Last update: ${hh}:${mm}`;
              }
              // Show maxindex in progress element if available
              if (streamGlobals.maxindex && streamGlobals.maxindex > 0) {
                prog.textContent = `Loaded 0 / ${streamGlobals.maxindex}`;
              }
              continue; // consumed globals
            }

            // The first object is likely the schema with __columns; subsequent objects are rows.
            if (!seenHeader && obj && obj.__columns) {
              seenHeader = true;
              continue; // skip schema object
            }
            if (obj && typeof obj === 'object' && Object.keys(obj).length === 1 && obj.error) {
              prog.textContent = `Error: ${obj.error}`;
              continue;
            }
            // If the object is a normal row, merge in globals so renderRow can read flags
            // (e.g., HASNOISE, HASIMAGES, LASTUPDATE)
            const payload = (obj && typeof obj === 'object')
              ? Object.assign({}, streamGlobals, obj)
              : obj;

            // Apply temporary noise prefix if configured and links exist
            if (payload && typeof payload === 'object' && cfg.noisePrefix) {
              const p = cfg.noisePrefix;
              if (payload['noisegraph:link'] && !payload['noisegraph:link'].startsWith('http') && !payload['noisegraph:link'].startsWith(p)) {
                payload['noisegraph:link'] = p + payload['noisegraph:link'];
              }
              if (payload['spectro:link'] && !payload['spectro:link'].startsWith('http') && !payload['spectro:link'].startsWith(p)) {
                payload['spectro:link'] = p + payload['spectro:link'];
              }
              if (payload['mp3:link'] && !payload['mp3:link'].startsWith('http') && !payload['mp3:link'].startsWith(p)) {
                payload['mp3:link'] = p + payload['mp3:link'];
              }
            }

        // Normalize payload row-level fields
            const norm = normalizeRow(payload);
            // Add the new row and record its numeric index for highlighting.
            addRow(norm);
            if (Number.isFinite(Number(norm.index))) {
              pendingNewIndices.add(Number(norm.index));
              updateNewUpdatesBanner();
            }
            added++;
            // Batch redraw every 10 rows for performance
            if (added % 10 === 0) {
              redraw(false);
              prog.textContent = `Loaded ${rowCount()}…`;
            }
          }
        }

  if (buf.trim()) { try { const last = JSON.parse(buf); addRow(last); if (Number.isFinite(Number(last.index))) { pendingNewIndices.add(Number(last.index)); updateNewUpdatesBanner(); } } catch(e){} }
  // Final redraw after stream completes or when reader is drained. Force a full
  // redraw so if the user is on the first page the new rows appear.
  redraw(true);
        if (!prog.textContent.startsWith('Error')) prog.textContent = `Done. Rows: ${rowCount()}`;
      } catch (e) {
        console.error('stream error', e);
        prog.textContent = 'Stream error';
      }
    })();
  }

// -------- Polling snapshot every 60s and apply incremental updates --------
// Uses same endpoint (`./cgi/stream.sh`) which emits NDJSON (globals, schema, rows)
// and updates existing rows (by index) or appends new rows. Does a single draw at end.
async function pollAndMerge() {
  try {
    const resp = await fetch('./cgi/stream.sh', { cache: 'no-store' });
    if (!resp.ok) { console.warn('poll: fetch failed', resp.status); return; }
    const txt = await resp.text();
    if (!txt) return;

    const lines = txt.split('\n');
    let localGlobals = {};
    let seenHeader = false;
  const toAdd = [];
  const toUpdate = [];
  // Track which numeric indices were present in the latest snapshot so we can purge missing rows
  const seenIndices = new Set();

    for (const line of lines) {
      if (!line.trim()) continue;
      let obj;
      try { obj = JSON.parse(line); } catch (e) { console.warn('poll: bad json', e, line); continue; }
      if (obj && obj.__globals) { localGlobals = obj.__globals || {};
        if (localGlobals.LASTUPDATE && Number.isFinite(Number(localGlobals.LASTUPDATE)) && Number(localGlobals.LASTUPDATE) > 0) {
          const dt = new Date(Number(localGlobals.LASTUPDATE) * 1000);
          const hh = String(dt.getHours()).padStart(2,'0');
          const mm = String(dt.getMinutes()).padStart(2,'0');
          lastUpdateEl.textContent = `Last update: ${hh}:${mm}`;
        }
        continue; }
      if (!seenHeader && obj && obj.__columns) { seenHeader = true; continue; }
      if (!obj || typeof obj !== 'object') continue;

      const payload = Object.assign({}, localGlobals, obj);
      // Same noise prefix handling as stream
      if (payload && typeof payload === 'object' && cfg.noisePrefix) {
        const p = cfg.noisePrefix;
        if (payload['noisegraph:link'] && !payload['noisegraph:link'].startsWith('http') && !payload['noisegraph:link'].startsWith(p)) {
          payload['noisegraph:link'] = p + payload['noisegraph:link'];
        }
        if (payload['spectro:link'] && !payload['spectro:link'].startsWith('http') && !payload['spectro:link'].startsWith(p)) {
          payload['spectro:link'] = p + payload['spectro:link'];
        }
        if (payload['mp3:link'] && !payload['mp3:link'].startsWith('http') && !payload['mp3:link'].startsWith(p)) {
          payload['mp3:link'] = p + payload['mp3:link'];
        }
      }

      const norm = normalizeRow(payload);
      const rendered = renderRow(norm);

      // Fast lookup: use rowByIndex map to find existing row by numeric index
      const numericIdx = Number(norm.index);
      if (Number.isFinite(numericIdx)) seenIndices.add(numericIdx);
      const foundApi = Number.isFinite(numericIdx) ? rowByIndex.get(numericIdx) : null;
      if (foundApi) {
        // Existing row: update and clear any missing counter
        toUpdate.push({ api: foundApi, row: rendered.row, idx: numericIdx });
        missingCounts.delete(numericIdx);
      } else {
        // New row: add and clear any missing counter (might have been previously missing)
        toAdd.push({ row: rendered.row, idx: numericIdx });
        missingCounts.delete(numericIdx);
      }
    }

    // Apply updates
    for (const u of toUpdate) {
      try {
        // Prefer direct API update. Some API objects may be stale before a draw,
        // so if this fails, fall back to locating the row node by data-idx.
        u.api.data(u.row);
      } catch(e) {
        console.warn('poll: update failed via api, trying fallback', e, u && u.idx);
        try {
          if (Number.isFinite(u.idx)) {
            const tr = document.querySelector(`tr[data-idx="${u.idx}"]`);
            if (tr) table.row(tr).data(u.row);
            else console.warn('poll: fallback row not found for idx', u.idx);
          }
        } catch (ee) { console.warn('poll: fallback update failed', ee); }
      }
    }
    // Append new rows and register them in rowByIndex
    for (const item of toAdd) {
      const apiRow = table.row.add(item.row);
      // If we know the numeric index, register the newly added row in the map
      try {
        if (Number.isFinite(item.idx)) {
          const node = apiRow.node();
          if (node) node.dataset.idx = item.idx;
          rowByIndex.set(item.idx, apiRow);
          // mark as pending so banner/highlight will show
          pendingNewIndices.add(Number(item.idx));
        } else {
          // Fallback: attempt to parse from the first-cell HTML
          const first = item.row && item.row[0] ? String(item.row[0]) : '';
          const m = first.match(/data-order="(-?\d+)"/);
          if (m) {
            const id = Number(m[1]);
            const node = apiRow.node();
            if (node) node.dataset.idx = id;
            rowByIndex.set(id, apiRow);
            pendingNewIndices.add(Number(id));
          }
        }
      } catch (e) { /* ignore */ }
    }

    // After applying updates/adds, purge any rows not present in the snapshot.
    // Purge rows that have been absent for at least 2 consecutive polls
    let purged = 0;
    try {
      for (const [idx, apiRow] of rowByIndex.entries()) {
        const nidx = Number(idx);
        if (seenIndices.has(nidx)) continue; // present in this snapshot

        // Increment miss counter
        const prev = missingCounts.get(nidx) || 0;
        const now = prev + 1;
        missingCounts.set(nidx, now);

        // If absent for 2 or more polls, purge it
        if (now >= 2) {
          try {
            const node = apiRow.node();
            if (node) table.row(node).remove();
          } catch (e) { /* ignore per-row remove errors */ }
          rowByIndex.delete(nidx);
          missingCounts.delete(nidx);
          purged++;
        }
      }
    } catch (e) { console.warn('poll: purge failed', e); }

    // Single redraw to refresh display (preserve paging)
    if (toUpdate.length || toAdd.length || purged) {
      table.draw(false);
      // After the draw, ensure any newly-created row nodes are registered in rowByIndex.
      try {
        table.rows().every(function(){
          const tr = this.node();
          if (!tr) return;
          // If the TR already has an idx, ensure the map contains it
          if (tr.dataset && tr.dataset.idx) {
            const id = Number(tr.dataset.idx);
            if (Number.isFinite(id) && !rowByIndex.has(id)) rowByIndex.set(id, table.row(tr));
            return;
          }
          // Otherwise try to parse the first-cell HTML for data-order and set dataset
          try {
            const d = this.data();
            const first = d && d[0] ? String(d[0]) : '';
            const m = first.match(/data-order="(-?\d+)"/);
            if (m) {
              const id = Number(m[1]);
              tr.dataset.idx = id;
              if (Number.isFinite(id)) rowByIndex.set(id, table.row(tr));
            }
          } catch (e) { /* ignore per-row */ }
        });
      } catch (e) { console.warn('poll: post-draw registration failed', e); }
  // If new rows were added during the poll, update the banner count.
  if (toAdd.length) updateNewUpdatesBanner();
  prog.textContent = `Updated ${toUpdate.length} / Added ${toAdd.length} / Purged ${purged} — Rows: ${rowCount()}`;
    }
  } catch (e) {
    console.error('pollAndMerge error', e);
  }
}

// Start polling if enabled. Run an immediate poll once and then schedule repeated polls.
if (cfg.enablePoll) {
  // Run immediately
  (async ()=>{
    await pollAndMerge();
    // schedule next
    scheduleNextPoll(cfg.pollIntervalSec || 60);
  })();
  // Schedule subsequent polls
  setInterval(async ()=>{ await pollAndMerge(); scheduleNextPoll(cfg.pollIntervalSec || 60); }, (cfg.pollIntervalSec || 60) * 1000);
}

// Manual Update button: trigger immediate poll
manualUpdateBtn?.addEventListener('click', async ()=>{
  if (!cfg.enablePoll) return;
  // Provide immediate feedback: disable button while running
  try {
    manualUpdateBtn.disabled = true;
    const prevText = manualUpdateBtn.textContent;
    manualUpdateBtn.textContent = 'Updating…';
    prog.textContent = 'Updating…';
    await pollAndMerge();
    scheduleNextPoll(cfg.pollIntervalSec || 60);
    manualUpdateBtn.textContent = prevText;
  } catch (e) {
    console.error('Manual update failed', e);
    prog.textContent = 'Update failed';
  } finally {
    manualUpdateBtn.disabled = false;
  }
});

// New-updates banner: when user clicks, jump to first page and show new rows
if (newUpdatesBtn) {
  newUpdatesBtn.addEventListener('click', ()=>{
    try {
      if (table) {
        table.page('first').draw(false);
        // After jumping, highlight pending rows
        highlightPendingNewRows();
      }
      newUpdatesBtn.style.display = 'none';
    } catch (e) { console.error('newUpdates click', e); }
  });
}

</script>

<!-- Modal for spectro preview -->
<div id="pf-modal" class="pf-modal" role="dialog" aria-hidden="true">
  <div class="box"><img id="pf-modal-img" src="" alt="preview"></div>
</div>

<script>
// Modal handlers
const modal = document.getElementById('pf-modal');
const modalImg = document.getElementById('pf-modal-img');
document.addEventListener('click', function(ev){
  const t = ev.target.closest && ev.target.closest('.spectro-thumb');
  if (t) {
    ev.preventDefault();
    const src = t.getAttribute('data-src');
    if (src) {
      modalImg.src = src;
      modal.classList.add('open');
      modal.setAttribute('aria-hidden','false');
    }
  }
  // close when clicking outside the box
  if (ev.target === modal) {
    modal.classList.remove('open'); modal.setAttribute('aria-hidden','true'); modalImg.src = '';
  }
});
document.addEventListener('keydown', function(ev){ if (ev.key === 'Escape') { modal.classList.remove('open'); modal.setAttribute('aria-hidden','true'); modalImg.src = ''; } });
</script>

</body></html>
