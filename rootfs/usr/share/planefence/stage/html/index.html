<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Planefence</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/datatables.net-dt/css/jquery.dataTables.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lipis/flag-icons@7.3.2/css/flag-icons.min.css">
  <!-- 1) CSS: row dim + small updater + dark zebra fix -->
  <style>

    /* Dim entire row while incomplete */
    tr.row-incomplete { color: var(--row-incomplete); }
    tr.row-incomplete a { color: inherit; }
    tr.row-incomplete .muted { color: inherit; opacity: .9; }

    /* Small “still updating” */
    .still-updating { font-size: 0.85em; }

    /* Override DataTables zebra to adapt to theme */
    table.dataTable.stripe tbody tr.odd,
    table.dataTable.display tbody tr.odd {
      background-color: var(--table-stripe);
    }
    /* Ensure even rows use base bg in both themes */
    table.dataTable tbody tr.even { background-color: var(--bg); }

    :root {
      color-scheme: light dark;
      /* height reserved for the top page header; table thead will stick beneath this */
      --header-height: 3.5rem;
      --bg: #ffffff;
      --fg: #111111;
      --muted: #666;
      --soft: #f5f5f5;
      --accent: #0b5fff;
      --danger-bg: #fff3f3;
      --danger-fg: #a40000;
      --row-incomplete: #6b6b6b;
      --chip-bg: #eee;
      --chip-fg: #222;
      --link: #0b5fff;
      --link-visited: #5a32a3;
      --table-stripe: #fafafa;
    }
    html.dark {
      --bg: #0f1115;
      --fg: #e6e6e6;
      --muted: #9aa0a6;
      --soft: #1a1d23;
      --accent: #6ca0ff;
      --danger-bg: #2a1212;
      --danger-fg: #ff8a8a;
      --row-incomplete: #9aa0a6;
      --chip-bg: #1f2430;
      --chip-fg: #e6e6e6;
      --link: #8fb1ff;
      --link-visited: #c6a6ff;
      --table-stripe: #151922;
    }

    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", sans-serif;
      background: var(--bg); color: var(--fg);
      line-height: 1.45;
    }
  header, footer { padding: .75rem 1rem; background: var(--soft); display: flex; align-items: center; gap: .75rem; }
  /* Keep header visible while scrolling */
  header { position: sticky; top: 0; z-index: 50; }
    header h1 { font-size: 1.1rem; margin: 0; font-weight: 600; }
    .station-headline { display: flex; align-items: baseline; margin-left: .75rem; font-size: 1rem; color: var(--muted); }
    .station-headline.station-headline-empty { display: none; }
    .station-headline a { color: var(--accent); font-weight: 600; text-decoration: none; }
    .station-headline a:hover, .station-headline a:focus-visible { text-decoration: underline; }
    header .spacer { flex: 1; }
    button, .btn {
      background: transparent; border: 1px solid var(--muted); color: var(--fg); padding: .35rem .6rem; border-radius: .5rem; cursor: pointer;
    }
    /* Force the theme toggle to inherit and display the foreground color explicitly */
    #themeToggle { color: var(--fg) !important; }
    #themeToggle svg { color: currentColor; }
    /* Ensure theme toggle SVG is visible in both themes */
    #themeToggle svg { width: 1.1em; height: 1.1em; display: inline-block; vertical-align: middle; }
    button:hover { border-color: var(--fg); }
    body.modal-open { overflow: hidden; }
    .station-info-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.55); display: none; align-items: center; justify-content: center; z-index: 1000; padding: 1rem; }
    .station-info-modal.open { display: flex; }
    .station-info-card { position: relative; background: var(--bg); color: var(--fg); border-radius: 1rem; max-width: 640px; width: min(640px, 100%); max-height: 90vh; overflow-y: auto; padding: 1.5rem; box-shadow: 0 20px 60px rgba(0,0,0,0.35); border: 1px solid rgba(0,0,0,0.08); }
    html.dark .station-info-card { border-color: rgba(255,255,255,0.08); box-shadow: 0 20px 60px rgba(0,0,0,0.65); }
    .station-info-close { background: none; border: none; color: inherit; font-size: 1.5rem; position: absolute; top: .5rem; right: 1rem; cursor: pointer; padding: .25rem; line-height: 1; }
    .station-info-card h1 { margin-top: 1.25rem; font-size: 1.2rem; }
    .station-info-card h1:first-of-type { margin-top: 0; }
    .station-info-card footer { margin-top: 1.5rem; border-top: 1px solid var(--soft); padding-top: 1rem; font-size: .9rem; }
    html.dark .station-info-card footer { border-color: rgba(255,255,255,0.1); }
    .station-info-card p { margin: .35rem 0; }
    .station-coords { font-weight: 600; white-space: nowrap; }
    .station-map-wrapper { margin: 1rem 0 0; border-radius: 0.75rem; overflow: hidden; border: 1px solid var(--soft); background: var(--soft); }
    html.dark .station-map-wrapper { border-color: rgba(255,255,255,0.08); background: #111421; }
    .station-map-frame { width: 100%; min-height: 260px; border: none; display: block; }
    .heatmap-modal { position: fixed; inset: 0; background: rgba(0, 3, 12, 0.75); display: none; align-items: center; justify-content: center; z-index: 1100; padding: 1rem; }
    .heatmap-modal.open { display: flex; }
    .heatmap-card { position: relative; background: var(--bg); border-radius: 1rem; width: min(1100px, 95vw); height: min(80vh, 720px); padding: 0; overflow: hidden; box-shadow: 0 25px 80px rgba(0,0,0,0.45); border: 1px solid rgba(0,0,0,0.08); display: flex; }
    html.dark .heatmap-card { border-color: rgba(255,255,255,0.12); }
    .heatmap-frame { border: none; width: 100%; height: 100%; background: #000; display: block; flex: 1; }
    .heatmap-close { position: absolute; top: .5rem; right: .75rem; background: rgba(0,0,0,0.65); color: #fff; border: none; font-size: 1.5rem; line-height: 1; padding: .2rem .75rem; border-radius: 999px; cursor: pointer; z-index: 1101; }
    .heatmap-loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 1rem; letter-spacing: .08em; text-transform: uppercase; background: rgba(0,0,0,0.55); padding: 0.65rem 1.25rem; border-radius: 999px; z-index: 1100; }
    .heatmap-loading.hidden { opacity: 0; pointer-events: none; }
    .photo-modal { position: fixed; inset: 0; background: rgba(0, 3, 12, 0.75); display: none; align-items: center; justify-content: center; z-index: 1080; padding: 1rem; }
    .photo-modal.open { display: flex; }
    .photo-card { position: relative; background: var(--bg); border-radius: 1rem; width: min(900px, 95vw); height: min(80vh, 720px); padding: 0; overflow: hidden; box-shadow: 0 25px 80px rgba(0,0,0,0.45); border: 1px solid rgba(0,0,0,0.08); display: flex; flex-direction: column; }
    html.dark .photo-card { border-color: rgba(255,255,255,0.12); }
    .photo-close { position: absolute; top: .5rem; right: .75rem; background: rgba(0,0,0,0.65); color: #fff; border: none; font-size: 1.5rem; line-height: 1; padding: .2rem .75rem; border-radius: 999px; cursor: pointer; z-index: 1101; }
    .photo-frame { flex: 1; background: #000; display: flex; align-items: center; justify-content: center; }
    .photo-frame img { max-width: 90%; max-height: 90%; object-fit: contain; }
    .photo-caption { padding: .75rem 1rem; font-size: .9rem; color: var(--muted); }
    a { color: var(--link); text-decoration: none; }
    a:visited { color: var(--link-visited); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .muted { color: var(--muted); }
    .status { margin-left: .5rem; }

    table.dataTable tbody tr:nth-child(odd) { background: var(--table-stripe); }
    table.dataTable thead th { white-space: nowrap; }
  /* Left-align all table headers for better readability */
  table.dataTable thead th, table#t thead th { text-align: left !important; }
  /* Normalize typography, spacing, and hierarchy inside the data table */
  table#t {
    font-family: inherit;
    font-size: 0.95rem;
    line-height: 1.4;
    border-collapse: separate;
    border-spacing: 0;
  }
  table#t thead th {
    font-size: 0.78rem;
    letter-spacing: 0.04em;
    text-transform: uppercase;
    font-weight: 600;
    color: var(--muted);
  }
  table#t thead th,
  table#t tbody td {
    padding: 0.65rem 0.85rem;
  }
  table#t tbody td {
    font-size: 0.95rem;
    line-height: 1.35;
  }
  table#t tbody td .muted {
    font-size: 0.85em;
  }
  table#t tbody td .aircraft-main {
    font-weight: 600;
  }
  table#t tbody td .secondary-line {
    display: block;
    margin-top: 0.15rem;
    font-size: 0.85em;
    color: var(--muted);
  }
  /* Removed Spectro column; kept layout flexible */
    /* Keep the table header visible while scrolling; it will sit just below the page header */
    table.dataTable thead th {
      position: sticky;
      top: var(--header-height);
      z-index: 40;
      background: var(--soft);
    }
    /* Give the first data row extra padding so it clears the sticky header */
    table.dataTable tbody tr:first-of-type > * {
      padding-top: 1.5rem;
    }
    th, td { vertical-align: middle; }
  img.thumb { height: 56px; width: 56px; object-fit: cover; border-radius: .25rem; background: #0001; }
  img.thumb.thumb-photo { cursor: zoom-in; }
  /* Silhouette thumbnails: keep width same as thumb, preserve aspect ratio */
  img.thumb.thumb-sil { width: 56px; height: auto; max-height: 56px; object-fit: contain; }
    .angle-img { height: 1em; vertical-align: -0.2em; margin-left: .25rem; }
  /* Position cell: give a little gap between coords and angle line */
  td.position-cell {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 0.15rem;
  }
  td.position-cell div { line-height: 1.25; }
  /* Ensure angle image aligns center with the angle text */
  .angle-img { vertical-align: middle; height: 1em; margin-left: .35rem; }
    .chip { display: inline-flex; align-items: center; gap: .35rem; background: var(--chip-bg); color: var(--chip-fg); padding: .1rem .4rem; border-radius: .5rem; font-size: .85em; }
  .dot { display:none; }
    .danger { background: var(--danger-bg); color: var(--danger-fg); font-weight: 600; padding: 0 .25em; border-radius: .25em; }
  /* small SVG icons inside chips — make slightly larger for visibility */
  .chip svg { height: 1.25em; width: 1.25em; vertical-align: -0.15em; }
  .chip.muted { opacity: 0.8; }
  .badge-icon { height: 1.25em; width: 1.25em; object-fit: contain; vertical-align: -0.15em; }
  /* Slightly increase chip padding for better tap targets and add spacing between chips */
  .chip { padding: 0.15rem 0.5rem; }
  .chip + .chip { margin-left: 0.35rem; }
  /* Tooltip hint for non-link notifications: underline only the label, not the chip outline */
  .chip.has-tooltip { cursor: help; }
  .chip.has-tooltip .label { border-bottom: 1px dotted currentColor; }
  /* Keep notifier icons at or below line height and align nicely */
  .ico { height: 1em; width: 1em; vertical-align: text-bottom; }
  .chip .ico { margin-right: .3rem; }
  /* For notifier links that are not chips (Notifications column), add spacing */
  td:nth-child(11) a .ico { margin-right: .3rem; }
  /* Center the empty state message nicely */
  td.dataTables_empty { height: 40vh; vertical-align: middle !important; text-align: center !important; color: var(--muted); }
  /* Improve spacing for notification chips inside the Notifications cell */
  td:nth-child(11) a.chip { margin-right: .25rem; }
  .plane-alert-cell a { display: inline-flex; align-items: center; gap: .3rem; line-height: inherit; font-size: inherit; }
  .plane-alert-favicon { width: 1em; height: 1em; object-fit: contain; border-radius: 2px; }
  .aircraft-main { display: block; }
  .aircraft-flag-icon {
    display: inline-flex;
    align-items: center;
    margin-right: .35rem;
    vertical-align: middle;
  }
  .aircraft-flag-icon img {
    height: 1em;
    width: calc(4/3 * 1em);
    object-fit: cover;
    border-radius: 2px;
    box-shadow: 0 0 0.5px rgba(0,0,0,0.4);
  }
  .route-chip {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    font-size: 0.85em;
    color: var(--muted);
    white-space: nowrap;
  }

  /* Visually hidden text for accessibility */
  .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 1px, 1px); border: 0; }
  /* In dark mode, invert bitmap badges so dark lines become light */
  html.dark .badge-icon { filter: invert(1) brightness(2) contrast(1.2); }

  /* Chips (small badges) should use the chip background color in dark mode */
  html.dark .chip { background: var(--chip-bg); color: var(--chip-fg); }

  /* Modal preview for spectro images */
  .pf-modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.7); align-items: center; justify-content: center; z-index: 9999; }
  .pf-modal.open { display: flex; }
  .pf-modal .box { max-width: 90%; max-height: 90%; border-radius: .5rem; overflow: hidden; box-shadow: 0 8px 32px rgba(0,0,0,.6); }
  .pf-modal img { display: block; max-width: 100%; max-height: 100%; }

    .seen-incomplete { color: var(--row-incomplete); }

    .nowrap { white-space: nowrap; }
  /* Prevent Seen column from collapsing too narrow */
  /* DataTables places columns in the table header; target the third th (index starts at 1) */
  /* Keep Seen column readable but compact: single-line with ellipsis if too long */
  table.dataTable thead th:nth-child(3),
  table.dataTable tbody td:nth-child(3) {
    width: 1%;
    white-space: nowrap;
  }
  table.dataTable tbody td:nth-child(3) {
    overflow: hidden;
    text-overflow: ellipsis;
  }
  /* Preserve legacy width for the Sound column (9th column) */
  table#t thead th:nth-child(9),
  table#t tbody td:nth-child(9) {
    min-width: 11rem;
    width: 11%;
  }
  /* Highlight freshly-added rows briefly (soft fade-out) */
  .pf-new-row { animation: pf-fade 2.2s ease-out; background-color: rgba(108,169,255,0.18); }
  @keyframes pf-fade { 0% { background-color: rgba(108,169,255,0.28); } 100% { background-color: transparent; } }
  /* Ensure DataTables respects theme colors in dark mode and doesn't leave
    white cells/stripes. Use !important where DataTables default CSS is stronger. */
  table.dataTable { background: transparent; }
  table.dataTable tbody td, table.dataTable tbody tr { background: transparent; }
  /* Regular stripe rules (light and dark) */
  table.dataTable.stripe tbody tr.odd,
  table.dataTable.display tbody tr.odd { background-color: var(--table-stripe) !important; }
  table.dataTable tbody tr.even { background-color: var(--bg) !important; }
  /* Dark-mode specific enforcement to override DataTables' defaults */
  html.dark table.dataTable.stripe tbody tr.odd,
  html.dark table.dataTable.display tbody tr.odd { background-color: var(--table-stripe) !important; }
  html.dark table.dataTable tbody tr.even { background-color: var(--bg) !important; }
  /* Ensure individual cells (including the index cell span) don't show white */
  html.dark table.dataTable tbody td, html.dark table.dataTable tbody td * { background: transparent !important; color: var(--fg) !important; }
  /* DataTables sometimes wraps table body for scrolling; ensure those cells are covered */
  html.dark .dataTables_scrollBody table tbody tr td { background: transparent !important; }

  /* New-updates button default style (light mode) */
  #newUpdates { background: var(--chip-bg); color: var(--chip-fg); border-color: var(--muted); }
  /* Dark-mode adjustments for banner/button */
  html.dark #newUpdates { background: rgba(108,169,255,0.08); color: var(--fg); border-color: rgba(255,255,255,0.06); }

  /* Make the new-row highlight slightly different in dark mode */
  html.dark .pf-new-row { background-color: rgba(108,169,255,0.12) !important; }

  /* Row hover: ensure hover color is theme-aware (not white in dark mode) */
  /* Light mode hover: subtle darker tint */
  table.dataTable tbody tr:hover { background-color: rgba(0,0,0,0.03) !important; }
  table.dataTable tbody tr:hover td, table.dataTable tbody tr:hover td * { background: transparent !important; }
  /* Dark mode hover: subtle light tint */
  html.dark table.dataTable tbody tr:hover { background-color: rgba(255,255,255,0.03) !important; }
  html.dark table.dataTable tbody tr:hover td, html.dark table.dataTable tbody tr:hover td * { background: transparent !important; }

  /* Toggle switch for theme */
  .switch { position: relative; display: inline-block; width: 44px; height: 24px; }
  .switch input { opacity: 0; width: 0; height: 0; }
  .switch .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background: var(--muted); transition: .2s ease; border-radius: 999px; }
  .switch .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; top: 3px; background: var(--bg); transition: .2s ease; border-radius: 50%; box-shadow: 0 1px 2px rgba(0,0,0,0.25); }
  .switch input:checked + .slider { background: var(--accent); }
  .switch input:checked + .slider:before { transform: translateX(20px); }
  .theme-toggle { display: flex; align-items: center; gap: .4rem; }
  .theme-toggle .theme-ico { display: inline-flex; color: var(--muted); opacity: .8; transition: color .2s ease, opacity .2s ease; font-size: 1.15rem; line-height: 1; }
  html.dark .theme-toggle .theme-ico.moon,
  html:not(.dark) .theme-toggle .theme-ico.sun { color: var(--accent); opacity: 1; }
  .header-divider { width: 1px; height: 1.5rem; background: var(--muted); opacity: .5; margin: 0 .75rem; }
  html.dark .header-divider { opacity: .35; }
  .mode-toggle { display: flex; align-items: center; gap: .35rem; font-size: .85rem; }
  .mode-toggle .mode-label { font-weight: 600; }
  .switch.switch-mode { width: 56px; height: 26px; }
  .switch.switch-mode .slider:before { width: 20px; height: 20px; top: 3px; }
  .switch.switch-mode input:checked + .slider:before { transform: translateX(28px); }
  .pf-controls { display: flex; flex-wrap: wrap; align-items: center; justify-content: space-between; gap: 1rem; margin-bottom: .5rem; }
  .pf-controls .pf-left { display: flex; align-items: center; }
  .pf-controls .pf-right { display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; justify-content: flex-end; }
  .pf-controls .pf-right .dataTables_filter { margin: 0; }
  .pf-controls .pf-right .dataTables_filter label { display: flex; align-items: center; gap: .35rem; margin: 0; }
  .pf-controls .pf-right .dataTables_info { margin: 0; white-space: nowrap; }
  .pf-controls .pf-right .dataTables_paginate { margin: 0; }
  </style>
</head>
<body>
  <header>
    <h1>Planefence</h1>
    <div id="stationHeadline" class="station-headline station-headline-empty">
      <a id="stationHeadlineLink" href="#" target="_blank" rel="noreferrer noopener"></a>
    </div>
    <span class="status mono" id="progress">Loading…</span>
  <span class="status mono" id="lastupdate" style="margin-left: .5rem"></span>
  <span class="status mono" id="nextupdate" style="margin-left: .75rem">Next update: --</span>
    <div class="spacer"></div>
    <div class="mode-toggle" role="group" aria-label="Choose data source">
      <span class="mode-label">Planefence</span>
      <label class="switch switch-mode" title="Toggle between Planefence and Plane-Alert data">
        <input id="dataModeToggle" type="checkbox" aria-label="Switch data source" />
        <span class="slider" aria-hidden="true"></span>
      </label>
      <span class="mode-label">Plane-Alert</span>
    </div>
    <div class="header-divider" aria-hidden="true"></div>
    <div class="theme-toggle">
      <span class="theme-ico sun" aria-hidden="true">&#9728;</span>
      <div class="theme-switch-wrap">
        <label class="switch" title="Toggle dark/light">
          <input id="themeToggle" type="checkbox" aria-label="Toggle theme" />
          <span class="slider" aria-hidden="true"></span>
        </label>
      </div>
      <span class="theme-ico moon" aria-hidden="true">&#9790;</span>
    </div>
  <button id="heatmapBtn" title="Show station heatmap" style="display:none;">Heatmap</button>
  <button id="stationInfoBtn" title="Show station information">Station Info</button>
  <button id="reload" title="Update data">Update</button>
  <button id="newUpdates" title="Show new updates" style="display:none; margin-left:.5rem;">New updates available</button>
  </header>

  <div id="stationInfoModal" class="station-info-modal" role="dialog" aria-modal="true" aria-labelledby="stationInfoTitle" aria-hidden="true">
    <div class="station-info-card">
      <button type="button" id="stationInfoClose" class="station-info-close" aria-label="Close station information">&times;</button>
      <div id="stationInfoContent" class="station-info-content"></div>
    </div>
  </div>

  <div id="heatmapModal" class="heatmap-modal" role="dialog" aria-modal="true" aria-label="Planefence heatmap" aria-hidden="true">
    <div class="heatmap-card">
      <button type="button" id="heatmapClose" class="heatmap-close" aria-label="Close heatmap">&times;</button>
      <iframe id="heatmapFrame" class="heatmap-frame" title="Planefence heatmap" loading="lazy" sandbox="allow-scripts allow-same-origin"></iframe>
      <div id="heatmapLoading" class="heatmap-loading">Preparing heatmap…</div>
    </div>
  </div>

  <div id="photoModal" class="photo-modal" role="dialog" aria-modal="true" aria-label="Aircraft photo" aria-hidden="true">
    <div class="photo-card">
      <button type="button" id="photoClose" class="photo-close" aria-label="Close photo">&times;</button>
      <div class="photo-frame">
        <img id="photoModalImg" src="" alt="" loading="lazy">
      </div>
      <div id="photoModalCaption" class="photo-caption"></div>
    </div>
  </div>

  <main style="padding: 0 1rem 1rem;">
    <div style="overflow:auto;">
      <table id="t" class="display compact stripe" style="width:100%;">
        <thead id="thead">
          <tr></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </main>

  <footer>
    <small class="muted">&copy; 2020-<span id="footerYear">2025</span> Ram&oacute;n F. Kolb, kx1t. All rights reserved. Code is licensable under the terms and conditions of GPLv3 - see <a href="https://github.com/kx1t/docker-planefence" target="_blank" rel="noreferrer noopener">Github repo</a>. Thanks to our <a href="https://github.com/sdr-enthusiasts/docker-planefence/graphs/contributors" target="_blank" rel="noreferrer noopener">repo contributors</a> and other external <a href="https://github.com/sdr-enthusiasts/docker-planefence/blob/main/ATTRIBUTION.md" target="_blank" rel="noreferrer noopener">contributors</a>. <span id="appVersionText">Version --</span></small>
  </footer>

  <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/datatables.net@2/js/dataTables.min.js"></script>
  <script src="./js/flags.js"></script>

  <script>
  // -------- Config --------
  const cfg = {
    // Base URL where docroot images live (arrowXXX_day|night.png, thumbnails if hosted locally)
    // Ensure trailing slash. Change as needed, e.g., `${location.origin}/assets/`
    // mediaBase: location.origin + 'assets/',
    mediaBase: './assets/',
    // Temporary prefix to apply to noise/spectro/mp3 links (easy to change)
    // Set to empty string to disable. Useful when those files are served under a subpath like /noise/
    // noisePrefix: './noise/',
  noisePrefix: './',
  // Directory for aircraft silhouettes (configurable). Ensure trailing slash.
  silhouetteDir: './assets/silhouettes/',
  // Optional per-badge images (inlined as data URI so the page doesn't need external assets)
  // The UI will use CSS (html.dark .badge-icon) to invert/brighten bitmap/SVG badges in dark mode.
    noiseIcon: 'data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2216%22%20height%3D%2216%22%3E%3Ccircle%20cx%3D%228%22%20cy%3D%228%22%20r%3D%226%22%20fill%3D%22%230b5fff%22/%3E%3C/svg%3E',
    mp3Icon: 'data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2216%22%20height%3D%2216%22%3E%3Ccircle%20cx%3D%228%22%20cy%3D%228%22%20r%3D%226%22%20fill%3D%22%23ff8a00%22/%3E%3C/svg%3E',
    // Enable or disable the live stream reader and/or periodic polling. Set one or both to true as needed.
    enableStream: true,
    enablePoll: true,
    // Poll interval in seconds (used when enablePoll is true)
    pollIntervalSec: 60
  };

  const FLAG_ICON_SRC_BASE = 'https://cdn.jsdelivr.net/gh/lipis/flag-icons@7.3.2/flags/4x3/';

  const STATION_INFO_TEMPLATE = `
<h1 class="station-welcome-title">Welcome to <a href="{{stationUrl}}" target="_blank" rel="noreferrer noopener">{{stationName}}</a> Planefence and Plane-Alert Station</h1>
<h1 id="stationInfoTitle">Planefence</h1>
Planefence shows all aircraft received today by this station within a range of {{dist}} {{distUnit}} and altitude below {{altitude}} {{altUnit}} from <span class="station-coords">{{latCardinal}}, {{lonCardinal}}</span>. Note that the station's actual location may differ as these coordinates may have been obfuscated for privacy reasons.
<div class="station-map-wrapper">
  <iframe id="stationInfoMapFrame" class="station-map-frame" title="Station coverage map" loading="lazy"></iframe>
</div>
<h1>Plane-Alert</h1>
Plane-Alert shows those aircraft in range of the station that are part of the station's <a href="alertlist.txt" target="_blank" rel="noreferrer noopener">watchlist</a>.
<h1>Messages</h1>
Today's data is derived from {{totalLines}} ADS-B messages received by the station since midnight
<footer>
<p>Planefence is &copy; 2020-{{year}} by Ram&oacute;n F. Kolb, kx1t and is available as source code or as a Docker container. See the <a href="https://sdr-e.com/docker-planefence" target="_blank" rel="noreferrer noopener">Github repository</a> for more information. Version: {{version}}</p>
<p>Planefence is made possible thanks to our <a href="https://github.com/sdr-enthusiasts/docker-planefence/graphs/contributors" target="_blank" rel="noreferrer noopener">repo contributors</a> and other external <a href="https://github.com/sdr-enthusiasts/docker-planefence/blob/main/ATTRIBUTION.md" target="_blank" rel="noreferrer noopener">contributors</a>.</p>
</footer>`;

  let prog, lastUpdateEl, nextUpdateEl, theadRow, reloadBtn, newUpdatesBtn, heatmapBtn;
  let stationHeadlineEl, stationHeadlineLink;
  let stationInfoBtn, stationInfoModal, stationInfoContentEl, stationInfoCloseBtn;
  let heatmapModal, heatmapFrame, heatmapCloseBtn, heatmapLoadingEl;
  let photoModal, photoModalImg, photoModalCloseBtn, photoModalCaption;
  let appVersionEl, footerYearEl;

  const truthy = (v) => {
    if (v === true || v === 1) return true;
    if (typeof v === 'string') {
      const s = v.toLowerCase();
      return s === 'true' || s === '1' || s === 'yes';
    }
    return false;
  };

    // -------- Data mode (Planefence vs Plane-Alert) --------
    const DATA_MODE_KEY = 'pf-data-mode';
    const DATA_MODES = {
      PLANEFENCE: 'planefence',
      PLANE_ALERT: 'plane-alert'
    };
    function modeFromQuery(){
      try {
        const params = new URLSearchParams(window.location.search || '');
        const raw = params.get('mode');
        if (!raw) return null;
        const normalized = raw.trim().toLowerCase();
        if (!normalized) return null;
        if (normalized === 'pf' || normalized === DATA_MODES.PLANEFENCE) return DATA_MODES.PLANEFENCE;
        if (normalized === 'pa' || normalized === DATA_MODES.PLANE_ALERT || normalized === 'planealert') return DATA_MODES.PLANE_ALERT;
        return null;
      } catch (e) {
        return null;
      }
    }
    function currentDataMode(){
      try {
        const saved = localStorage.getItem(DATA_MODE_KEY);
        return saved === DATA_MODES.PLANE_ALERT ? DATA_MODES.PLANE_ALERT : DATA_MODES.PLANEFENCE;
      } catch (e) {
        return DATA_MODES.PLANEFENCE;
      }
    }
    const presetMode = modeFromQuery();
    if (presetMode) {
      try { localStorage.setItem(DATA_MODE_KEY, presetMode); } catch (e) { /* ignore */ }
    }
    let dataMode = presetMode || currentDataMode();
    function isPlaneAlertMode(){
      return dataMode === DATA_MODES.PLANE_ALERT;
    }
    function applyDataModeUI(){
      const toggle = document.getElementById('dataModeToggle');
      if (toggle) {
        try { toggle.checked = isPlaneAlertMode(); } catch (e) { /* ignore */ }
        const label = isPlaneAlertMode() ? 'Switch to Planefence data' : 'Switch to Plane-Alert data';
        toggle.setAttribute('aria-label', label);
      }
      const heading = document.querySelector('header h1');
      if (heading) heading.textContent = isPlaneAlertMode() ? 'Plane-Alert' : 'Planefence';
      const body = document.body;
      if (body) {
        body.classList.toggle('mode-plane-alert', isPlaneAlertMode());
        body.classList.toggle('mode-planefence', !isPlaneAlertMode());
      }
      updateHeatmapButtonState();
    }
    applyDataModeUI();
    let modeGeneration = 0;
    let streamAbortController = null;
    let pollIntervalHandle = null;
    function buildStreamUrl(mode){
      const base = './cgi/stream.sh';
      return mode === DATA_MODES.PLANE_ALERT ? `${base}?mode=plane-alert` : base;
    }
    function currentStreamUrl(){
      return buildStreamUrl(dataMode);
    }
    (function(){
      const toggle = document.getElementById('dataModeToggle');
      if (!toggle) return;
      toggle.addEventListener('change', ()=>{
        const newMode = toggle.checked ? DATA_MODES.PLANE_ALERT : DATA_MODES.PLANEFENCE;
        if (newMode === dataMode) return;
        try { localStorage.setItem(DATA_MODE_KEY, newMode); } catch (e) { /* ignore */ }
        dataMode = newMode;
        applyDataModeUI();
        applyPlaneAlertColumnVisibility();
        restartDataPipelines();
      });
    })();

  // -------- Theme (dark/light) --------
  const THEME_KEY = 'pf-theme';
  function applyTheme(theme){
    const dark = theme === 'dark';
    document.documentElement.classList.toggle('dark', dark);
    const toggle = document.getElementById('themeToggle');
    if (toggle) {
      const label = dark ? 'Switch to light theme' : 'Switch to dark theme';
      toggle.setAttribute('aria-label', label);
      try { toggle.checked = dark; } catch(e) { /* ignore */ }
    }
    localStorage.setItem(THEME_KEY, theme);
    // After theme flip, update arrow images to day/night variants without full re-render
    try { updateAngleImagesForTheme(dark); } catch(e) { /* ignore */ }
  }
  function currentTheme(){
    const saved = localStorage.getItem(THEME_KEY);
    if (saved === 'dark' || saved === 'light') return saved;
    return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
  }
  applyTheme(currentTheme());
  // On initial apply, ensure arrow images reflect theme
  try { updateAngleImagesForTheme(document.documentElement.classList.contains('dark')); } catch(e){}
  (function(){
    const t = document.getElementById('themeToggle');
    if (!t) return;
    // Ensure initial checked reflects current theme
    try { t.checked = document.documentElement.classList.contains('dark'); } catch(e){}
    t.addEventListener('change', () => {
      const useDark = !!t.checked;
      applyTheme(useDark ? 'dark' : 'light');
      // No need to invalidate rows just to swap arrow icons; we directly update sources.
    });
  })();

  // -------- Helpers --------
  document.addEventListener('DOMContentLoaded', ()=>{
    prog = document.getElementById('progress');
    if (prog) prog.textContent = isPlaneAlertMode() ? 'Loading Plane-Alert…' : 'Loading…';
    lastUpdateEl = document.getElementById('lastupdate');
    nextUpdateEl = document.getElementById('nextupdate');
    theadRow = document.querySelector('#thead tr');
    reloadBtn = document.getElementById('reload');
    reloadBtn?.addEventListener('click', () => location.reload());
    newUpdatesBtn = document.getElementById('newUpdates');
    heatmapBtn = document.getElementById('heatmapBtn');
    stationHeadlineEl = document.getElementById('stationHeadline');
    stationHeadlineLink = document.getElementById('stationHeadlineLink');
    stationInfoBtn = document.getElementById('stationInfoBtn');
    stationInfoModal = document.getElementById('stationInfoModal');
    stationInfoContentEl = document.getElementById('stationInfoContent');
    stationInfoCloseBtn = document.getElementById('stationInfoClose');
    heatmapModal = document.getElementById('heatmapModal');
    heatmapFrame = document.getElementById('heatmapFrame');
    heatmapCloseBtn = document.getElementById('heatmapClose');
    heatmapLoadingEl = document.getElementById('heatmapLoading');
    photoModal = document.getElementById('photoModal');
    photoModalImg = document.getElementById('photoModalImg');
    photoModalCloseBtn = document.getElementById('photoClose');
    photoModalCaption = document.getElementById('photoModalCaption');
    appVersionEl = document.getElementById('appVersionText');
    footerYearEl = document.getElementById('footerYear');
    if (footerYearEl) footerYearEl.textContent = String(new Date().getFullYear());
    updateFooterVersionText('');
    refreshStationInfoContent();
    updateStationHeadline();
    updateHeatmapButtonState();
    stationInfoBtn?.addEventListener('click', openStationInfoModal);
    stationInfoCloseBtn?.addEventListener('click', closeStationInfoModal);
    stationInfoModal?.addEventListener('click', (ev) => {
      if (ev.target === stationInfoModal) closeStationInfoModal();
    });
    heatmapBtn?.addEventListener('click', openHeatmapModal);
    heatmapCloseBtn?.addEventListener('click', closeHeatmapModal);
    heatmapModal?.addEventListener('click', (ev) => {
      if (ev.target === heatmapModal) closeHeatmapModal();
    });
    photoModalCloseBtn?.addEventListener('click', closePhotoModal);
    photoModal?.addEventListener('click', (ev) => {
      if (ev.target === photoModal) closePhotoModal();
    });
    heatmapFrame?.addEventListener('load', () => {
      if (heatmapModal?.classList.contains('open')) setHeatmapLoading(false);
    });
    setHeatmapLoading(true);
    setupThumbnailInteractions();
  }, { once: true });

  const stationInfoState = {
    dist: null,
    distUnit: '',
    altitude: null,
    altUnit: '',
    lat: null,
    lon: null,
    totalLines: null,
    version: '',
    heatmapZoom: null,
    stationName: '',
    stationUrl: ''
  };
  let stationInfoLastFocus = null;
  let heatmapLastFocus = null;
  let photoModalLastFocus = null;
  const heatmapState = {
    lat: null,
    lon: null,
    distMeters: null,
    dateStr: '',
    zoom: 11
  };
  let hasNoiseAvailable = false;

  function setHasNoiseAvailability(value) {
    const next = truthy(value);
    if (hasNoiseAvailable !== next) {
      hasNoiseAvailable = next;
      applyPlaneAlertColumnVisibility();
    }
  }

  function setHeatmapLoading(active) {
    if (!heatmapLoadingEl) return;
    if (active) heatmapLoadingEl.classList.remove('hidden');
    else heatmapLoadingEl.classList.add('hidden');
  }

  function convertDistanceToMeters(value, unit) {
    const num = Number(value);
    if (!Number.isFinite(num)) return null;
    const normalized = String(unit || '').trim().toLowerCase();
    const unitMap = {
      nm: 1852,
      'nmi': 1852,
      mi: 1609,
      mile: 1609,
      miles: 1609,
      km: 1000,
      kilometer: 1000,
      kilometers: 1000,
      m: 1,
      meter: 1,
      meters: 1
    };
    const factor = unitMap[normalized];
    if (factor) return Math.round(num * factor);
    return Math.round(num);
  }

  function formatHeatmapDate(globals) {
    const ts = globals && globals.LASTUPDATE ? Number(globals.LASTUPDATE) : NaN;
    const date = Number.isFinite(ts) && ts > 0 ? new Date(ts * 1000) : new Date();
    const yy = String(date.getUTCFullYear()).slice(-2);
    const mm = String(date.getUTCMonth() + 1).padStart(2, '0');
    const dd = String(date.getUTCDate()).padStart(2, '0');
    return `${yy}${mm}${dd}`;
  }

  function resolveHeatmapZoom() {
    const candidate = Number(stationInfoState.heatmapZoom);
    if (Number.isFinite(candidate) && candidate > 0) return candidate;
    return 11;
  }

  function isHeatmapDataReady() {
    return Number.isFinite(heatmapState.lat)
      && Number.isFinite(heatmapState.lon)
      && Number.isFinite(heatmapState.distMeters)
      && typeof heatmapState.dateStr === 'string'
      && heatmapState.dateStr.length === 6;
  }

  function updateHeatmapButtonState() {
    if (!heatmapBtn) return;
    const visible = !isPlaneAlertMode();
    heatmapBtn.style.display = visible ? 'inline-block' : 'none';
    heatmapBtn.disabled = !visible || !isHeatmapDataReady();
  }

  function updateHeatmapState(globals) {
    const latVal = truncateCoord(stationInfoState.lat);
    const lonVal = truncateCoord(stationInfoState.lon);
    const distMeters = convertDistanceToMeters(stationInfoState.dist, stationInfoState.distUnit);
    const dateStr = formatHeatmapDate(globals || {});
    const zoomLevel = resolveHeatmapZoom();
    let changed = false;
    if (!Object.is(heatmapState.lat, latVal)) { heatmapState.lat = latVal; changed = true; }
    if (!Object.is(heatmapState.lon, lonVal)) { heatmapState.lon = lonVal; changed = true; }
    if (!Object.is(heatmapState.distMeters, distMeters)) { heatmapState.distMeters = distMeters; changed = true; }
    if (heatmapState.dateStr !== dateStr) { heatmapState.dateStr = dateStr; changed = true; }
    if (!Object.is(heatmapState.zoom, zoomLevel)) { heatmapState.zoom = zoomLevel; changed = true; }
    if (changed) updateHeatmapButtonState(); else if (heatmapBtn) heatmapBtn.disabled = !isHeatmapDataReady() || isPlaneAlertMode();
  }

  function buildStationMapHtml() {
    const lat = truncateCoord(stationInfoState.lat);
    const lon = truncateCoord(stationInfoState.lon);
    const distMeters = convertDistanceToMeters(stationInfoState.dist, stationInfoState.distUnit);
    if (lat == null || lon == null || !Number.isFinite(distMeters)) return '';
    const radius = Math.max(0, Math.round(distMeters));
    const zoomLevel = resolveHeatmapZoom();
    const latStr = lat.toFixed(2);
    const lonStr = lon.toFixed(2);
    const baseHref = String(document.baseURI || location.href).replace(/"/g, '&quot;');
    return `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Station Coverage</title>
  <base href="${baseHref}">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <style>
    html, body { height: 100%; margin: 0; }
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #0b1725; }
    #map { width: 100%; height: 100%; }
  </style>
</head>
<body>
  <div id="map"></div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"><\/script>
  <script>
    var map = L.map('map').setView([parseFloat('${latStr}'), parseFloat('${lonStr}')], ${zoomLevel});
    L.tileLayer('https://{s}.tile.osm.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);
    L.tileLayer('https://{s}.api.tiles.openaip.net/api/data/openaip/{z}/{x}/{y}.png?apiKey=', {
      attribution: '<a href="http://www.openaip.net">OpenAIP.net</a>'
    }).addTo(map);
    var circle = L.circle([parseFloat('${latStr}'), parseFloat('${lonStr}')], {
      color: 'blue',
      fillColor: '#0b5fff',
      fillOpacity: 0.12,
      radius: ${radius}
    }).addTo(map);
    map.fitBounds(circle.getBounds(), { padding: [20, 20] });
  <\/script>
</body>
</html>`;
  }

  function buildHeatmapHtml() {
    const lat = Number(heatmapState.lat);
    const lon = Number(heatmapState.lon);
    const dist = Math.max(0, Math.round(Number(heatmapState.distMeters)));
    const dateStr = heatmapState.dateStr;
    const latStr = lat.toFixed(2);
    const lonStr = lon.toFixed(2);
    const zoomLevel = Number.isFinite(Number(heatmapState.zoom)) ? Number(heatmapState.zoom) : 11;
    const baseHref = String(document.baseURI || location.href).replace(/"/g, '&quot;');
    return `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Planefence Heatmap</title>
  <base href="${baseHref}">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <style>
    html, body { height: 100%; margin: 0; }
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #0b1725; color: #fff; display: flex; }
    #map { flex: 1; min-height: 0; }
  </style>
</head>
<body>
  <div id="map"></div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"><\/script>
  <script src="./js/heatlayer.js"><\/script>
  <script src="./js/leaflet-heat.js"><\/script>
  <script src="./js/planeheatdata.js"><\/script>
  <script>
    var map = L.map('map').setView([parseFloat('${latStr}'), parseFloat('${lonStr}')], ${zoomLevel});
    var tiles = L.tileLayer('https://{s}.tile.osm.org/{z}/{x}/{y}.png', {
      attribution: '<a href="https://github.com/Leaflet/Leaflet.heat">Leaflet.heat</a> , &copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);
    if (typeof addressPoints === 'undefined') { addressPoints = []; }
    addressPoints = addressPoints.map(function (p) { return [p[0], p[1]]; });
    var heat = L.heatLayer(addressPoints, {
      minOpacity: 1,
      radius: 7,
      maxZoom: 14,
      blur: 11,
      attribution: '<a href="https://sdr-e.com/docker-planefence" target="_blank">Planefence</a>'
    }).addTo(map);
    var circle = L.circle([ parseFloat('${latStr}'), parseFloat('${lonStr}')], {
      color: 'blue',
      fillColor: '#f03',
      fillOpacity: 0.1,
      radius: ${dist}
    }).addTo(map);
    var openaip_cached_basemap = new L.TileLayer('https://{s}.api.tiles.openaip.net/api/data/openaip/{z}/{x}/{y}.png?apiKey=', {
      attribution: '<a href="http://www.openaip.net">OpenAIP.net</a>'
    }).addTo(map);
    map.fitBounds(circle.getBounds(), { padding: [20, 20] });
  <\/script>
</body>
</html>`;
  }

  function openHeatmapModal() {
    if (!isHeatmapDataReady()) {
      alert('Heatmap data is not ready yet.');
      return;
    }
    if (!heatmapModal || !heatmapFrame) return;
    setHeatmapLoading(true);
    heatmapFrame.srcdoc = buildHeatmapHtml();
    heatmapLastFocus = document.activeElement;
    heatmapModal.classList.add('open');
    heatmapModal.setAttribute('aria-hidden', 'false');
    document.body.classList.add('modal-open');
    heatmapCloseBtn?.focus({ preventScroll: true });
  }

  function closeHeatmapModal() {
    if (!heatmapModal) return;
    heatmapModal.classList.remove('open');
    heatmapModal.setAttribute('aria-hidden', 'true');
    document.body.classList.remove('modal-open');
    if (heatmapFrame) {
      heatmapFrame.srcdoc = '';
    }
    setHeatmapLoading(true);
    if (heatmapLastFocus && typeof heatmapLastFocus.focus === 'function') {
      heatmapLastFocus.focus({ preventScroll: true });
    }
    heatmapLastFocus = null;
  }

  function openPhotoModal(src, caption, linkHref) {
    if (!photoModal || !photoModalImg) return;
    const safeSrc = String(src || '').trim();
    if (!safeSrc) return;
    photoModalImg.src = safeSrc;
    photoModalImg.alt = caption || 'Aircraft photo';
    if (photoModalCaption) {
      const safeCaption = caption || '';
      const linkHtml = linkHref ? `<a href="${linkHref}" target="_blank" rel="noopener">Planespotters.net</a>` : '';
      photoModalCaption.innerHTML = `${safeCaption}${linkHtml ? ` · ${linkHtml}` : ''}`;
    }
    photoModalLastFocus = document.activeElement;
    photoModal.classList.add('open');
    photoModal.setAttribute('aria-hidden', 'false');
    document.body.classList.add('modal-open');
    photoModalCloseBtn?.focus({ preventScroll: true });
  }

  function closePhotoModal() {
    if (!photoModal) return;
    photoModal.classList.remove('open');
    photoModal.setAttribute('aria-hidden', 'true');
    document.body.classList.remove('modal-open');
    if (photoModalImg) photoModalImg.src = '';
    if (photoModalLastFocus && typeof photoModalLastFocus.focus === 'function') {
      photoModalLastFocus.focus({ preventScroll: true });
    }
    photoModalLastFocus = null;
  }

  function thumbnailTargetData(target) {
    if (!target) return null;
    const img = target.closest && target.closest('img.thumb');
    if (!img || img.classList.contains('thumb-sil')) return null;
    const fullSrc = img.getAttribute('data-fullsrc');
    if (!fullSrc) return null;
    return {
      fullSrc,
      caption: img.getAttribute('data-caption') || 'Aircraft photo',
      sourceLink: img.getAttribute('data-sourcelink') || ''
    };
  }

  function handleThumbnailClick(ev) {
    const data = thumbnailTargetData(ev.target);
    if (!data) return;
    ev.preventDefault();
    openPhotoModal(data.fullSrc, data.caption, data.sourceLink);
  }

  function handleThumbnailKeydown(ev) {
    if (ev.key !== 'Enter' && ev.key !== ' ') return;
    const data = thumbnailTargetData(ev.target);
    if (!data) return;
    ev.preventDefault();
    openPhotoModal(data.fullSrc, data.caption, data.sourceLink);
  }

  function setupThumbnailInteractions() {
    document.addEventListener('click', handleThumbnailClick);
    document.addEventListener('keydown', handleThumbnailKeydown);
  }

  function updateFooterVersionText(value) {
    if (!appVersionEl) return;
    const label = value ? `Version ${value}` : 'Version --';
    appVersionEl.textContent = label;
  }

  const numberFmt0 = new Intl.NumberFormat(undefined, { maximumFractionDigits: 0 });
  const numberFmt1 = new Intl.NumberFormat(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 1 });
  const coordFmt = new Intl.NumberFormat(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 2 });

  function escapeHtml(value) {
    return String(value ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  function replaceTemplatePlaceholders(template, replacements) {
    return Object.entries(replacements).reduce((acc, [token, rawValue]) => {
      const safeVal = rawValue ?? '--';
      const pattern = token.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      return acc.replace(new RegExp(pattern, 'g'), safeVal);
    }, template);
  }

  function formatStationDistance(value) {
    const num = Number(value);
    if (Number.isFinite(num)) {
      return (num < 10 ? numberFmt1.format(num) : numberFmt0.format(Math.round(num)));
    }
    if (value != null && value !== '') return escapeHtml(value);
    return '--';
  }

  function formatStationAltitude(value) {
    const num = Number(value);
    if (Number.isFinite(num)) return numberFmt0.format(num);
    if (value != null && value !== '') return escapeHtml(value);
    return '--';
  }

  function truncateCoord(value) {
    const num = Number(value);
    if (!Number.isFinite(num)) return null;
    return Math.trunc(num * 100) / 100;
  }

  function formatStationCoord(value) {
    const truncated = truncateCoord(value);
    if (truncated != null) return coordFmt.format(truncated);
    if (value != null && value !== '') return escapeHtml(value);
    return '--';
  }

  function formatStationCardinalCoord(value, axis) {
    const truncated = truncateCoord(value);
    if (truncated == null) {
      return formatStationCoord(value);
    }
    const absVal = Math.abs(truncated).toFixed(2);
    const dir = axis === 'lat'
      ? (truncated >= 0 ? 'N' : 'S')
      : (truncated >= 0 ? 'E' : 'W');
    return `${absVal}&deg; ${dir}`;
  }

  function formatStationTotal(value) {
    const num = Number(value);
    if (Number.isFinite(num)) return numberFmt0.format(num);
    if (value != null && value !== '') return escapeHtml(value);
    return '--';
  }

  function buildStationInfoHtml() {
    const replacements = {
      '{{stationName}}': escapeHtml(stationInfoState.stationName || 'this'),
      '{{stationUrl}}': escapeHtml(stationInfoState.stationUrl || 'https://sdr-e.com/docker-planefence'),
      '{{dist}}': formatStationDistance(stationInfoState.dist),
      '{{distUnit}}': escapeHtml(stationInfoState.distUnit || '--'),
      '{{altitude}}': formatStationAltitude(stationInfoState.altitude),
      '{{altUnit}}': escapeHtml(stationInfoState.altUnit || '--'),
      '{{latCardinal}}': formatStationCardinalCoord(stationInfoState.lat, 'lat'),
      '{{lonCardinal}}': formatStationCardinalCoord(stationInfoState.lon, 'lon'),
      '{{totalLines}}': formatStationTotal(stationInfoState.totalLines),
      '{{year}}': String(new Date().getFullYear()),
      '{{version}}': escapeHtml(stationInfoState.version || '--')
    };
    return replaceTemplatePlaceholders(STATION_INFO_TEMPLATE, replacements);
  }

  function refreshStationInfoContent() {
    if (!stationInfoContentEl) return;
    stationInfoContentEl.innerHTML = buildStationInfoHtml();
    const mapFrame = stationInfoContentEl.querySelector('#stationInfoMapFrame');
    if (mapFrame) {
      const mapDoc = buildStationMapHtml();
      if (mapDoc) {
        mapFrame.srcdoc = mapDoc;
      } else {
        const wrapper = mapFrame.closest('.station-map-wrapper');
        if (wrapper) wrapper.style.display = 'none';
      }
    }
  }

  function updateStationHeadline() {
    if (!stationHeadlineEl || !stationHeadlineLink) return;
    const rawName = stationInfoState.stationName;
    const name = typeof rawName === 'string' ? rawName.trim() : '';
    const rawUrl = stationInfoState.stationUrl;
    const url = typeof rawUrl === 'string' ? rawUrl.trim() : '';
    if (name && url) {
      stationHeadlineLink.textContent = name;
      stationHeadlineLink.setAttribute('href', url);
      stationHeadlineLink.setAttribute('target', '_blank');
      stationHeadlineLink.setAttribute('rel', 'noreferrer noopener');
      stationHeadlineEl.classList.remove('station-headline-empty');
    } else {
      stationHeadlineLink.textContent = '';
      stationHeadlineLink.removeAttribute('href');
      stationHeadlineLink.removeAttribute('target');
      stationHeadlineLink.removeAttribute('rel');
      stationHeadlineEl.classList.add('station-headline-empty');
    }
  }

  function openStationInfoModal() {
    if (!stationInfoModal) return;
    refreshStationInfoContent();
    stationInfoLastFocus = document.activeElement;
    stationInfoModal.classList.add('open');
    stationInfoModal.setAttribute('aria-hidden', 'false');
    document.body.classList.add('modal-open');
    stationInfoCloseBtn?.focus({ preventScroll: true });
  }

  function closeStationInfoModal() {
    if (!stationInfoModal) return;
    stationInfoModal.classList.remove('open');
    stationInfoModal.setAttribute('aria-hidden', 'true');
    document.body.classList.remove('modal-open');
    if (stationInfoLastFocus && typeof stationInfoLastFocus.focus === 'function') {
      stationInfoLastFocus.focus({ preventScroll: true });
    }
    stationInfoLastFocus = null;
  }

  function getGlobalValue(globals, key) {
    if (!globals || typeof globals !== 'object') return undefined;
    if (Object.prototype.hasOwnProperty.call(globals, key)) return globals[key];
    if (key.includes(':')) {
      const dotKey = key.replace(/:/g, '.');
      if (Object.prototype.hasOwnProperty.call(globals, dotKey)) return globals[dotKey];
    }
    return undefined;
  }

  function updateStationInfoFromGlobals(globals) {
    if (!globals || typeof globals !== 'object') return;
    let changed = false;
    const mapping = [
      ['dist', 'station:dist:value'],
      ['distUnit', 'station:dist:unit'],
      ['altitude', 'station:altitude:value'],
      ['altUnit', 'station:altitude:unit'],
      ['lat', 'station:lat'],
      ['lon', 'station:lon'],
      ['version', 'station:version'],
      ['heatmapZoom', 'station:heatmapzoom'],
      ['stationName', 'station:me'],
      ['stationUrl', 'station:myurl']
    ];
    for (const [stateKey, globalKey] of mapping) {
      const raw = getGlobalValue(globals, globalKey);
      if (raw === undefined || raw === '' || raw == null) continue;
      const numeric = Number(raw);
      const nextVal = Number.isFinite(numeric) ? numeric : String(raw);
      if (stationInfoState[stateKey] === nextVal) continue;
      stationInfoState[stateKey] = nextVal;
      if (stateKey === 'version') {
        updateFooterVersionText(nextVal);
      }
      changed = true;
    }
    if ('totallines' in globals) {
      const tot = Number(globals.totallines);
      if (Number.isFinite(tot) && stationInfoState.totalLines !== tot) {
        stationInfoState.totalLines = tot;
        changed = true;
      }
    }
    updateHeatmapState(globals);
    if (changed) {
      refreshStationInfoContent();
      updateStationHeadline();
    }
  }

  document.addEventListener('keydown', (ev) => {
    if (ev.key === 'Escape' && stationInfoModal?.classList.contains('open')) {
      ev.preventDefault();
      closeStationInfoModal();
    } else if (ev.key === 'Escape' && heatmapModal?.classList.contains('open')) {
      ev.preventDefault();
      closeHeatmapModal();
    } else if (ev.key === 'Escape' && photoModal?.classList.contains('open')) {
      ev.preventDefault();
      closePhotoModal();
    }
  });


  function updateNewUpdatesBanner(){
    try {
      if (!newUpdatesBtn) return;
      const count = pendingNewIndices.size || 0;
      if (count > 0) {
        newUpdatesBtn.textContent = `New updates (${count})`;
      } else {
        newUpdatesBtn.textContent = 'New updates available';
        newUpdatesBtn.style.display = 'none';
      }
    } catch (e) { /* ignore */ }
  }

  // Next-poll tracking (timestamp in ms)
  let nextPollAt = null;
  let countdownTimerId = null;

  function startCountdown() {
    if (!nextUpdateEl) return;
    if (countdownTimerId) clearInterval(countdownTimerId);
    countdownTimerId = setInterval(()=>{
      if (!nextPollAt) { nextUpdateEl.textContent = 'Next update: --'; return; }
      const sec = Math.max(0, Math.round((nextPollAt - Date.now())/1000));
      nextUpdateEl.textContent = `Next update: ${sec}s`;
    }, 250);
  }

  function scheduleNextPoll(afterSec) {
    nextPollAt = Date.now() + (afterSec * 1000);
    startCountdown();
  }

  // Toggle countdown and manual update UI depending on polling configuration
  if (!cfg.enablePoll) {
    if (nextUpdateEl) nextUpdateEl.style.display = 'none';
  }

  // Expose a global rowCount helper so non-streaming code (poller, UI) can query
  // current number of rows without depending on the streaming IIFE's local function.
  function rowCount() {
    try {
      if (!table) return 0;
      return Math.max(0, table.rows().count());
    } catch (e) { return 0; }
  }

  function fmtInt(s){ const n = Number(s); return Number.isFinite(n)? n : null; }
  function safe(s){ return String(s ?? ""); }
  function isHttp(u){ return typeof u === 'string' && /^https?:\/\//i.test(u); }
  function toFixed4(n){ const x = Number(n); return Number.isFinite(x)? x.toFixed(4) : ""; }
  function degBucket10(n){
    const num = Number(n);
    if (!Number.isFinite(num)) return null;
    const rounded = Math.round(num);
    let b = Math.round(rounded/10)*10;
    b = ((b % 360) + 360) % 360;
    if (b === 360) b = 0;
    return b;
  }
  function angleAssetName(deg, dark){
    const b = degBucket10(deg);
    if (b==null) return null;
    return `arrow${b}_${dark? 'night':'day'}.png`;
  }

  // Swap existing angle image sources to match theme without re-rendering rows
  function updateAngleImagesForTheme(dark){
    const imgs = document.querySelectorAll('img.angle-img');
    imgs.forEach(img => {
      try {
        const src = img.getAttribute('src') || '';
        // Replace day/night suffix if present
        const newSrc = src.replace(/arrow(\d{1,3})_(day|night)\.png$/i, (m, num) => `arrow${num}_${dark ? 'night':'day'}.png`);
        if (newSrc !== src) img.setAttribute('src', newSrc);
      } catch(e) { /* per-image ignore */ }
    });
  }

  const tzAbbrev = (() => {
    try {
      const fmt = new Intl.DateTimeFormat(undefined, { timeZoneName: 'short' });
      const parts = fmt.formatToParts(new Date());
      const tzPart = parts.find(p => p.type === 'timeZoneName');
      return tzPart ? tzPart.value : '';
    } catch (e) {
      return '';
    }
  })();

  // 3) Seen rendering helpers
  function formatRelativeOrDate(ts){
    const num = Number(ts);
    if (!Number.isFinite(num) || num <= 0) return '';
    const nowMs = Date.now();
    const tsMs = num * 1000;
    const diffSec = Math.max(0, Math.floor((nowMs - tsMs) / 1000));
    if (diffSec < 60) return `${diffSec}s ago`;
    if (diffSec < 3600) return `${Math.floor(diffSec / 60)}m ago`;
    if (diffSec < 86400) return `${Math.floor(diffSec / 3600)}h ago`;
    return new Intl.DateTimeFormat(undefined, { year: 'numeric', month: 'short', day: 'numeric' }).format(new Date(tsMs));
  }

  function normalizeNoiseLink(value) {
    const raw = String(value || '').trim();
    if (!raw) return '';
    if (/^(?:[a-z]+:)?\/\//i.test(raw) || raw.startsWith('noise/')) return raw;
    return `noise/${raw.replace(/^\/+/, '')}`;
  }

  function formatClockOrDate(ts){
    const num = Number(ts);
    if (!Number.isFinite(num) || num <= 0) return { text: '--', isTime: false };
    const dt = new Date(num * 1000);
    const now = new Date();
    const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    if (dt >= todayStart) {
      return {
        text: new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit', hour12: false }).format(dt),
        isTime: true
      };
    }
    const month = new Intl.DateTimeFormat(undefined, { month: 'short' }).format(dt);
    const day = String(dt.getDate()).padStart(2, '0');
    return { text: `${month}-${day}`, isTime: false };
  }

  function formatSeen(firstTs, closestTs, lastTs, completeFlag){
    const firstStr = formatRelativeOrDate(firstTs);
    const closestStr = formatRelativeOrDate(closestTs);
    const lastStr = formatRelativeOrDate(lastTs || closestTs || firstTs);
    if (!firstStr && !closestStr && !lastStr) return '';
    const closestPrimary = closestStr || lastStr || firstStr || '--';
    const primary = `closest ${closestPrimary}`;
    const firstLine = formatClockOrDate(firstTs);
    const closestLine = formatClockOrDate(closestTs);
    const lastLine = formatClockOrDate(lastTs || closestTs || firstTs);
    const timelineCore = [firstLine.text, closestLine.text, lastLine.text].join(' / ');
    const hasTimeValue = firstLine.isTime || closestLine.isTime || lastLine.isTime;
    const timeline = (tzAbbrev && hasTimeValue) ? `${timelineCore} ${tzAbbrev}` : timelineCore;
    const updating = (String(completeFlag) !== 'true')
      ? `<div class="still-updating">still updating</div>` : '';
    return `<div class="mono">${primary}</div><div class="mono">${timeline}</div>${updating}`;
  }


  function hasSound(r){
    return r['sound:peak'] || r['sound:loudness'] || r['sound:color'] || r['noisegraph:link'];
  }
  function hasNotifications(r){
    return r['discord:link'] || r['bsky:link'] || r['mastodon:link'] || r['telegram:link'] || r['mqtt:notified'] || r['mastodon:notified'];
  }

  // Normalize per-row values into typed fields so rendering is consistent
  function normalizeRow(r) {
    if (!r || typeof r !== 'object') return r;
    const out = Object.assign({}, r);
    out.HASNOISE = truthy(out.HASNOISE || out.hasOwnProperty('HASNOISE') && out.HASNOISE);
    out.HASIMAGES = truthy(out.HASIMAGES || out.hasOwnProperty('HASIMAGES') && out.HASIMAGES);
    out.HASROUTE = truthy(out.HASROUTE || out.hasOwnProperty('HASROUTE') && out.HASROUTE);
    out.complete = String(out.complete) === 'true' || out.complete === true;
    // Coerce notified flags
    out['discord:notified'] = truthy(out['discord:notified']);
    out['bsky:notified'] = truthy(out['bsky:notified']);
    out['telegram:notified'] = truthy(out['telegram:notified']);
    out['mastodon:notified'] = truthy(out['mastodon:notified']);
    out['mqtt:notified'] = truthy(out['mqtt:notified']);
    // Numeric conversions
    out.index = Number(out.index);
    out['time:lastseen'] = Number(out['time:lastseen']) || Number(out['time:firstseen']) || 0;
    out['time:firstseen'] = Number(out['time:firstseen']) || 0;
    out['time:time_at_mindist'] = Number(out['time:time_at_mindist']) || 0;
    out['sound:peak'] = out['sound:peak'] !== '' ? out['sound:peak'] : null;
    out['sound:loudness'] = out['sound:loudness'] !== '' ? out['sound:loudness'] : null;
    return out;
  }

  // Small inline SVG icon helpers
  // Graph icon for noisegraph PNG link
  function iconNoise(){
    return `<svg class="ico" viewBox="0 0 24 24" aria-hidden="true" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M3 19h18v2H3z" opacity=".25"/><path d="M7 15h2v4H7v-4zm4-6h2v10h-2V9zm4 3h2v7h-2v-7zM3 12h2v10H3V12z"/></svg>`;
  }
  // Music/note icon for mp3 link
  function iconMp3(){
    return `<svg class="ico" viewBox="0 0 24 24" aria-hidden="true" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 3v10.55A4 4 0 1 0 14 17V7h4V3h-6z"/></svg>`;
  }
  function iconSpectro(){ return `<svg class="ico" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" xmlns="http://www.w3.org/2000/svg"><path d="M5 15h2V9H5v6zm3 3h2V6H8v12zm3-1h2V7h-2v10zm3-3h2V9h-2v5zm3 4h2V6h-2v12z"/></svg>` }
  // Notifier icons (simple inline SVGs for Discord, Telegram, Bluesky)
  function iconDiscord(){ return `<svg class="ico" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M20 4a16 16 0 0 0-4-.9l-.2.3c1.6.4 2.8 1 3.7 1.7-1.6-.8-3.2-1.3-4.9-1.6a16.2 16.2 0 0 0-5 0C7 3.7 5.4 4.2 3.8 5c.9-.7 2.1-1.3 3.7-1.7L7.3 3A16 16 0 0 0 3 4.1C1 7 0 10 0 13.1c2.1 2.2 4.8 3.8 7.9 4.4l.6-.9c-1.7-.5-3.2-1.3-4.5-2.4 1.6 1.2 3.6 2.1 5.8 2.5a17.3 17.3 0 0 0 6.5-.1c2.2-.4 4.2-1.3 5.8-2.5-1.3 1.1-2.8 1.9-4.5 2.4l.6.9a16.8 16.8 0 0 0 7.9-4.4C24 10 23 7 21 4.1zM8.7 14.6c-1 0-1.8-.9-1.8-2s.8-2 1.8-2 1.8.9 1.8 2-.8 2-1.8 2zm6.6 0c-1 0-1.8-.9-1.8-2s.8-2 1.8-2 1.8.9 1.8 2-.8 2-1.8 2z"/></svg>` }
  function iconTelegram(){ return `<svg class="ico" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M9.036 15.803l-.376 5.3c.539 0 .771-.231 1.048-.508l2.515-2.41 5.213 3.81c.957.528 1.64.252 1.9-.887l3.447-16.128h.001c.306-1.424-.514-1.979-1.449-1.63L1.4 9.79c-1.371.532-1.35 1.297-.233 1.64l5.8 1.811 13.476-8.51c.635-.387 1.217-.173.74.214L9.036 15.803z"/></svg>` }
  function iconBluesky(){ return `<svg class="ico" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M12 6c1.2-2 3.2-4 5.2-4 1.8 0 2.6 1.3 2.6 2.7 0 2.2-1.5 4.3-3.3 6 2.1-.5 4.5-1.7 5.5-3.4.6 3-2.2 5.4-5.5 6.7 2.8.7 5.1 2.1 5.1 4.2 0 1.4-1 2.2-2.4 2.2-2 0-4.2-1.9-6.2-4.2-2 2.4-4.2 4.2-6.2 4.2-1.4 0-2.4-.8-2.4-2.2 0-2.1 2.3-3.5 5.1-4.2-3.3-1.3-6.1-3.7-5.5-6.7 1 1.7 3.4 2.9 5.5 3.4-1.8-1.7-3.3-3.8-3.3-6C6.2 3.3 7 2 8.8 2 10.8 2 12.8 4 14 6h-2z"/></svg>` }
  function iconMastodon(){ return `<svg class="ico" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M12 2c-4.6 0-8.3 1.5-8.3 6.8 0 4.3-.1 9.7 5.4 10.9 2.1.5 3.9.6 5.9 0 1.3-.4 4.5-1 4.9-4.9.1-1 .1-2.8.1-4.1 0-5.3-3.7-6.8-8.3-6.8Zm4.1 8.5v4.9h-2.4v-4.7c0-1-.4-1.5-1.1-1.5-.8 0-1.2.5-1.2 1.6v4.6H8.8v-4.9c0-1-.4-1.5-1.1-1.5-.8 0-1.2.5-1.2 1.6v4.6H4.1V10c0-1 .2-1.7.5-2.3.6-1.2 2.1-1.9 3.7-1.9 1.7 0 2.9.6 3.7 1.9.8-1.3 2-1.9 3.7-1.9 1.6 0 3.1.7 3.7 1.9.4.6.5 1.3.5 2.3Z"/></svg>` }
  function iconMQTT(){ return `<svg class="ico" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M12 2a10 10 0 100 20 10 10 0 000-20zm-1 5h2v6h-2V7zm1 10a1.5 1.5 0 110-3 1.5 1.5 0 010 3z"/></svg>` }

  // Helper to render notifier link with icon
  function notifierLink(href, label, iconHtml){
    const safeHref = String(href || '').replace(/"/g, '&quot;');
    return `<a class="chip" href="${safeHref}" target="_blank" rel="noopener">${iconHtml || ''}${label}</a>`;
  }

  function flagInfoForIcao(icao){
    try {
      if (!icao || typeof findICAORange !== 'function') return null;
      const clean = String(icao).trim();
      if (!clean) return null;
      const range = findICAORange(clean.toLowerCase());
      if (!range || !range.country_code) return null;
      return {
        code: String(range.country_code).toLowerCase(),
        name: range.country || ''
      };
    } catch (e) {
      return null;
    }
  }

  function renderFlagIconForIcao(icao){
    const info = flagInfoForIcao(icao);
    if (!info) return '';
    const title = info.name ? info.name.replace(/"/g, '&quot;') : '';
    const src = `${FLAG_ICON_SRC_BASE}${info.code}.svg`;
    return `<span class="aircraft-flag-icon" title="${title}" aria-label="${title}"><img src="${src}" alt="${title}"></span>`;
  }

  function hostnameFromUrl(urlValue){
    try {
      if (!urlValue) return "";
      const parsed = new URL(urlValue, location.href);
      return parsed.hostname || "";
    } catch (e) {
      return "";
    }
  }

  function planeAlertFaviconUrl(href){
    const host = hostnameFromUrl(href);
    if (!host) return null;
    const lower = host.toLowerCase();
    const faviconHost = lower === 'w.wiki' ? 'en.wikipedia.org' : host;
    return `https://${faviconHost}/favicon.ico`;
  }

  // -------- Columns definition --------
  const PLANE_ALERT_COL_KEY = 'planealert';
  const viewCols = [
    { key:"idx", title:"#", width:"4%" },
    { key:"thumb", title:"Image", width:"6%" },
  { key:"when", title:"Time (first / closest / last)" },
    { key:"aircraft", title:"Aircraft", width:"22%" },
  // Route column removed; route will be shown in Aircraft column after callsign
  // Position column slightly narrower (~70% of previous). Previous was 16%.
  { key:"position", title:"Position", width:"11%" },
    // Combined Alt/Spd column: both values shown on separate lines inside the same cell
  // Make Alt/Spd (speed) about 50% of previous width
  { key:"altspd", title:"Alt / Spd", width:"7%" },
    { key:"trk", title:"Track", width:"7%" },
  { key:"squawk", title:"Squawk", width:"8%" },
  { key:"sound", title:"Sound" },
    { key: PLANE_ALERT_COL_KEY, title:"Plane-Alert Tags", width:"12%" },
    { key:"notify", title:"Notifications", width:"12%" }
  ];

  function columnIndexByKey(key){
    return viewCols.findIndex(c => c.key === key);
  }

  function applyPlaneAlertColumnVisibility(){
    try {
      if (!table) return;
      const planeAlertIdx = columnIndexByKey(PLANE_ALERT_COL_KEY);
      const soundIdx = columnIndexByKey('sound');
      const planeAlertVisible = isPlaneAlertMode();
      const soundVisible = !isPlaneAlertMode() && hasNoiseAvailable;

      if (planeAlertIdx !== -1) {
        const col = table.column(planeAlertIdx);
        if (col && col.visible() !== planeAlertVisible) col.visible(planeAlertVisible, false);
      }
      if (soundIdx !== -1) {
        const colSound = table.column(soundIdx);
        if (colSound && colSound.visible() !== soundVisible) colSound.visible(soundVisible, false);
      }
      table.columns().adjust();
      table.draw(false);
    } catch (e) { /* ignore visibility issues */ }
  }

  let table = null;
  // Map of index -> DataTables row API for fast incremental updates
  const rowByIndex = new Map();
  // Map of index -> consecutive-miss count used to implement a grace period before purging
  const missingCounts = new Map();
  // Track indices added since last user-visible redraw. Used to highlight new rows.
  const pendingNewIndices = new Set();

  function resetTableState(){
    try {
      if (table) table.clear().draw(false);
    } catch (e) { /* ignore */ }
    rowByIndex.clear();
    missingCounts.clear();
    pendingNewIndices.clear();
    updateNewUpdatesBanner();
    if (newUpdatesBtn) newUpdatesBtn.style.display = 'none';
    if (prog) prog.textContent = isPlaneAlertMode() ? 'Loading Plane-Alert…' : 'Loading…';
  }

  function highlightPendingNewRows(){
    try {
      if (!table) return;
      pendingNewIndices.forEach(idx => {
        const tr = document.querySelector(`tr[data-idx="${idx}"]`);
        if (tr) {
          tr.classList.add('pf-new-row');
          setTimeout(()=> tr.classList.remove('pf-new-row'), 2200);
        }
      });
      pendingNewIndices.clear();
    } catch (e) { /* ignore */ }
  }

  function redrawTable(forceFull=false){
    try {
      if (!table) return;
      const info = table.page ? table.page.info() : null;
      const onFirst = info && info.page === 0;
      if (forceFull || onFirst) {
        table.order([[0,'desc']]).page('first').draw(false);
        highlightPendingNewRows();
        if (newUpdatesBtn) newUpdatesBtn.style.display = 'none';
      } else {
        if (newUpdatesBtn) {
          newUpdatesBtn.style.display = 'inline-block';
          updateNewUpdatesBanner();
        }
        table.order([[0,'desc']]).draw(false);
      }
    } catch (e) { console.error('redraw error', e); }
  }

  // 2) DataTables init: numeric sort for idx, keep Seen desc
 function buildHeader(){
   if (!theadRow) theadRow = document.querySelector('#thead tr');
   if (!theadRow) return;
  theadRow.innerHTML = "";
  for (const c of viewCols){
    const th = document.createElement('th');
    const headerHtml = c.titleHtml ?? c.title ?? '';
    if (c.titleHtml) th.innerHTML = headerHtml;
    else th.textContent = headerHtml;
    if (c.width) th.style.width = c.width;
    theadRow.appendChild(th);
  }

  // Replace Alt / Spd header content with clickable sort controls for numeric sorting
  try {
    const altIdx = viewCols.findIndex(v => v.key === 'altspd');
    if (altIdx >= 0) {
      const th = theadRow.children[altIdx];
      if (th) {
        th.innerHTML = `Alt / Spd <span style="margin-left:.5rem; font-size:0.85em; color:var(--muted);">` +
          `<a href="#" id="sortAlt" title="Sort by altitude (toggle asc/desc)" style="margin-right:.4rem;">Alt</a>` +
          `<a href="#" id="sortSpd" title="Sort by speed (toggle asc/desc)">Spd</a>` +
          ` <span id="sortDir" class="mono" aria-hidden="true" style="margin-left:.25rem;"></span>`+
          `</span>`;
        // Wire click handlers which compute the Alt/Spd column index at runtime,
        // copy the chosen numeric attribute into data-order, and toggle
        // ascending/descending on each click.
        setTimeout(()=>{
          const aAlt = document.getElementById('sortAlt');
          const aSpd = document.getElementById('sortSpd');
          // determine column index dynamically from the header cell position
          const colIdx = (typeof th?.cellIndex === 'number') ? th.cellIndex : altIdx;

          const copyAttrToDataOrder = (attrName) => {
            try {
              const nodes = table.column(colIdx, {order:'applied'}).nodes();
              const arr = nodes.toArray ? nodes.toArray() : Array.from(nodes);
              for (const td of arr) {
                try {
                  const inner = td.querySelector && (td.querySelector(`[data-${attrName}]`) || td.querySelector('[data-order]')) || td;
                  if (inner && inner.setAttribute) {
                    const v = inner.getAttribute && inner.getAttribute(`data-${attrName}`);
                    if (v != null) inner.setAttribute('data-order', v);
                  }
                } catch(e) { /* per-cell ignore */ }
              }
            } catch(e) { console.warn('copyAttrToDataOrder failed', e); }
          };

          if (aAlt) aAlt.addEventListener('click', (ev)=>{
            ev.preventDefault();
            // Toggle direction state stored on the TH element
            try {
              const prev = th.dataset.altDir || 'desc';
              const dir = prev === 'asc' ? 'desc' : 'asc';
              th.dataset.altDir = dir;
              copyAttrToDataOrder('order-alt');
              table.settings()[0].aoColumns[colIdx].orderDataType = 'dom-data-order';
              const dirSpan = document.getElementById('sortDir');
              if (dirSpan) dirSpan.textContent = dir === 'asc' ? '▲' : '▼';
              table.order([[colIdx, dir]]).draw(false);
            } catch(e) { console.warn('sortAlt failed', e); }
          });

          if (aSpd) aSpd.addEventListener('click', (ev)=>{
            ev.preventDefault();
            try {
              const prev = th.dataset.spdDir || 'desc';
              const dir = prev === 'asc' ? 'desc' : 'asc';
              th.dataset.spdDir = dir;
              copyAttrToDataOrder('order-spd');
              table.settings()[0].aoColumns[colIdx].orderDataType = 'dom-data-order';
              const dirSpan = document.getElementById('sortDir');
              if (dirSpan) dirSpan.textContent = dir === 'asc' ? '▲' : '▼';
              table.order([[colIdx, dir]]).draw(false);
            } catch(e) { console.warn('sortSpd failed', e); }
          });
        }, 0);
      }
    }
  } catch (e) { /* ignore header wiring errors */ }

  // Create DataTable and capture API
  // Ordering plugin: read numeric value from an inner element's data-order attribute
  // and use that as the sort key for the column. This ensures the index column
  // sorts by the numeric index we embed in the rendered HTML.
  jQuery.fn.dataTable.ext.order['dom-data-order'] = function(settings, col) {
    return this.api().column(col, {order:'index'}).nodes().map(function(td){
      try {
        // If DataTables gives us an Element, query inside it
        if (td && td.querySelector) {
          const el = td.querySelector('[data-order]');
          if (el) {
            const v = el.getAttribute('data-order');
            const n = Number(v);
            return Number.isFinite(n) ? n : v;
          }
        }
        // Sometimes with deferRender DataTables may return a plain string for the cell.
        // Handle that by parsing the HTML string for data-order instead of using querySelector.
        if (typeof td === 'string') {
          const m = td.match(/data-order="(-?\d+)"/);
          if (m) return Number(m[1]);
        }
      } catch (e) { /* ignore */ }
      // fallback: parse numeric from text content (covers both Element and string)
      const txt = (td && td.textContent) ? td.textContent.trim() : (typeof td === 'string' ? td : '');
      const n2 = Number(txt.replace(/[^0-9.\-]/g,''));
      return Number.isFinite(n2) ? n2 : txt;
    });
  };

  // Ordering plugin for Altitude (reads numeric value from data-order-alt)
  jQuery.fn.dataTable.ext.order['dom-data-order-alt'] = function(settings, col) {
    return this.api().column(col, {order:'index'}).nodes().map(function(td){
      try {
        if (td && td.querySelector) {
          const el = td.querySelector('[data-order-alt]');
          if (el) {
            const v = el.getAttribute('data-order-alt');
            const n = Number(v);
            return Number.isFinite(n) ? n : v;
          }
        }
        if (typeof td === 'string') {
          const m = td.match(/data-order-alt="(-?\d+)"/);
          if (m) return Number(m[1]);
        }
      } catch (e) { /* ignore */ }
      const txt = (td && td.textContent) ? td.textContent.trim() : (typeof td === 'string' ? td : '');
      const n2 = Number(txt.replace(/[^0-9.\-]/g,''));
      return Number.isFinite(n2) ? n2 : txt;
    });
  };

  // Ordering plugin for Speed (reads numeric value from data-order-spd)
  jQuery.fn.dataTable.ext.order['dom-data-order-spd'] = function(settings, col) {
    return this.api().column(col, {order:'index'}).nodes().map(function(td){
      try {
        if (td && td.querySelector) {
          const el = td.querySelector('[data-order-spd]');
          if (el) {
            const v = el.getAttribute('data-order-spd');
            const n = Number(v);
            return Number.isFinite(n) ? n : v;
          }
        }
        if (typeof td === 'string') {
          const m = td.match(/data-order-spd="(-?\d+)"/);
          if (m) return Number(m[1]);
        }
      } catch (e) { /* ignore */ }
      const txt = (td && td.textContent) ? td.textContent.trim() : (typeof td === 'string' ? td : '');
      const n2 = Number(txt.replace(/[^0-9.\-]/g,''));
      return Number.isFinite(n2) ? n2 : txt;
    });
  };

  const api = $('#t').DataTable({
    dom: '<"pf-controls"<"pf-left"l><"pf-right"fip>>rt',
    // Enable deferRender for performance; ordering reads sort keys from data-order attributes with fallbacks.
    deferRender: true,
    pageLength: 100,
    lengthMenu: [[25, 50, 100, -1], ['25', '50', '100', 'All']],
    responsive: true,
  // Default ordering: newest (highest index) first
  order: [[0, 'desc']],
    language: { emptyTable: 'Waiting for aircraft… Data will appear as it arrives.' },
    columns: viewCols.map(_ => ({ title: _.title })),
    columnDefs: [
      // Use our dom-data-order plugin for column 0 (index) so sorting honors
      // the numeric value placed in the cell's data-order attribute.
      {
        targets: 0,
        orderDataType: 'dom-data-order',
        type: 'num',
        // Ensure numeric sort even if the order plugin isn't engaged by parsing
        // the data-order attribute or falling back to numeric text extraction.
        render: {
          _: function(data) { return data; },
          sort: function(data) {
            try {
              const s = String(data || '');
              const m = s.match(/data-order="(-?\d+)"/);
              if (m) return Number(m[1]);
              const n = Number(s.replace(/[^0-9.\-]/g, ''));
              return Number.isFinite(n) ? n : 0;
            } catch (e) { return 0; }
          }
        }
      },
      // For Alt/Spd column (index 5 in viewCols), allow numeric ordering by
      // altitude or by speed via our custom orderDataType plugins. We'll
      // wire header click handlers to call the appropriate ordering.
      { targets: 5, orderDataType: 'dom-data-order-alt' },
      { targets: "_all", render: (data)=>data }
    ],
    createdRow: function(row, data){
      // Mark rows that are still updating
      if ((data?.[2] || '').includes('still-updating')) {
        row.classList.add('row-incomplete');
      } else {
        row.classList.remove('row-incomplete');
      }

      // Try to extract numeric index from the first-cell HTML and stash it on the TR.
      try {
        const first = data && data[0] ? String(data[0]) : '';
        const m = first.match(/data-order="(-?\d+)"/);
        if (m) {
          const id = Number(m[1]);
          row.dataset.idx = id;
          // If the table API is available, store the API row reference for fast lookup
          if (table) rowByIndex.set(id, table.row(row));
        }
      } catch (e) { /* ignore */ }
    }
  });

  // Store globally if you need it
  table = api;
  window.table = api;

  applyPlaneAlertColumnVisibility();

  // Preserve top row when the page length changes: capture current display start
  // and restore it after DataTables applies the new length. This keeps the
  // same top row visible and lets additional rows appear below it.
  try {
    const lenSel = document.querySelector('#t_length select');
    if (lenSel) {
      let anchorIdx = null;
      // On focus store the numeric index value from the first logical row using DOM if available.
      // Using DOM is more robust now that deferRender is disabled; fallback to column data if needed.
      lenSel.addEventListener('focus', ()=>{
        try {
          const info = table.page ? table.page.info() : null;
          if (!info) return;
          const start = info.start || 0;
          // Prefer reading from the visible DOM row if present
          const tr = document.querySelector('#t tbody tr');
          if (tr && tr.dataset && tr.dataset.idx) {
            anchorIdx = Number(tr.dataset.idx);
            return;
          }
          // Fallback: use column data
          const colData = table.column(0, {order: 'applied'}).data();
          if (!colData || colData.length === 0) { anchorIdx = null; return; }
          const cell = String(colData[start] || '');
          const m = cell.match(/data-order="(-?\d+)"/);
          anchorIdx = m ? Number(m[1]) : null;
        } catch (e) { anchorIdx = null; }
      });

      lenSel.addEventListener('change', ()=>{
        try {
          if (anchorIdx == null) return;
          // After the change, give DataTables a tick to reflow, then try to locate the
          // same anchor index in the newly ordered column data. We aggressively
          // invalidate rows to ensure data() returns DOM/HTML we can parse.
          setTimeout(()=>{
            try {
              try { table.rows().invalidate(); } catch(e) { /* ignore */ }
              const col = table.column(0, {order: 'applied'});
              const colDataArr = col.data().toArray ? col.data().toArray() : Array.from(col.data());
              const ids = colDataArr.map(c => {
                const s = String(c || '');
                const m = s.match(/data-order="(-?\d+)"/);
                return m ? Number(m[1]) : null;
              });
              const pos = ids.indexOf(Number(anchorIdx));
              if (pos >= 0) {
                const newPage = Math.floor(pos / table.page.len());
                table.page(newPage).draw(false);
              } else {
                // Fallback: go to first page so user sees newest rows
                table.page('first').draw(false);
              }
            } catch (e) { console.warn('anchor restore failed', e); table.page('first').draw(false); }
            anchorIdx = null;
          }, 50);
        } catch (e) { anchorIdx = null; }
      });
    }
  } catch(e) { /* ignore */ }

  // Populate rowByIndex for any rows DataTables already created during init
  try {
    api.rows().every(function(){
      const tr = this.node();
      if (!tr) return;
      const d = this.data();
      const first = d && d[0] ? String(d[0]) : '';
      const m = first.match(/data-order="(-?\d+)"/);
      if (m) {
        const id = Number(m[1]);
        tr.dataset.idx = id;
        rowByIndex.set(id, api.row(tr));
      }
    });
  } catch (e) { /* ignore */ }

  // Bind draw handler AFTER api exists
  api.on('draw', function(){
    // Only rows in the current page are guaranteed to have nodes
    api.rows({ page: 'current' }).every(function(){
      const tr = this.node();
      if (!tr) return; // node may be null when not in DOM
      const seenCell = (this.data()?.[2] || '');
      if (seenCell.includes('still-updating')) tr.classList.add('row-incomplete');
      else tr.classList.remove('row-incomplete');
    });
  });
}

// Helper: expand comma-separated discord links in the Notifications column.
// If a cell contains a single anchor whose href contains commas (multiple URLs),
// or if the cell has a data-discord-links attribute with comma-separated URLs,
// create an anchor for each URL labeled 'Discord'. This runs after table draws
// so it will affect both streaming and polled updates.
function expandDiscordLinksInNotifications() {
  try {
    if (!table) return;
    // Find all cells in the Notifications column (last column index)
    const notifColIdx = viewCols.findIndex(c => c.key === 'notify');
    if (notifColIdx === -1) return;
    // For each visible row cell in the column
    table.column(notifColIdx, {page: 'current'}).nodes().each(function(td){
      try {
        const cell = td instanceof Element ? td : (td && td.node) ? td.node : null;
        if (!cell) return;

        // First, check for a data attribute with comma-separated links
        const dataVal = cell.getAttribute && cell.getAttribute('data-discord-links');
        let links = null;
        if (dataVal) {
          links = dataVal.split(',').map(s => s.trim()).filter(Boolean);
        } else {
          // Otherwise, if there's exactly one anchor, look at its raw attribute value
          const anchors = cell.querySelectorAll && cell.querySelectorAll('a');
          if (anchors && anchors.length === 1) {
            const a = anchors[0];
            const rawHref = a.getAttribute && a.getAttribute('href');
            if (rawHref && rawHref.includes(',')) {
              links = rawHref.split(',').map(s => s.trim()).filter(Boolean);
            }
          }
          // If no anchors or single-anchor case didn't detect commas, also try plain text (comma-separated URLs)
          if (!links) {
            const txt = (cell.textContent || '').trim();
            if (txt && txt.includes(',')) {
              // Split and keep probable URLs (simple heuristic: starts with http or /)
              const candidates = txt.split(',').map(s => s.trim()).filter(Boolean);
              const probable = candidates.filter(s => /^https?:\/\//i.test(s) || s.startsWith('/'));
              if (probable.length > 0) links = probable;
            }
          }
        }

        if (!links || links.length <= 1) return; // nothing to do

        // Clear existing content and append an anchor per link, separated by middot
        cell.innerHTML = '';
        const multi = links.length > 1;
        links.forEach((lnk, i) => {
          const a = document.createElement('a');
          a.href = lnk;
          a.target = '_blank';
          a.rel = 'noopener';
          a.textContent = multi ? `Discord (${i+1})` : 'Discord';
          cell.appendChild(a);
          if (i !== links.length - 1) cell.appendChild(document.createTextNode(' · '));
        });
      } catch (e) { /* per-cell ignore */ }
    });
  } catch (e) { console.warn('expandDiscordLinksInNotifications failed', e); }
}

// Hook into DataTables draw event so newly-rendered pages have expanded links
if (typeof table !== 'undefined' && table) {
  table.on && table.on('draw', expandDiscordLinksInNotifications);
}

// Also call once after initial setup if table exists
setTimeout(()=> expandDiscordLinksInNotifications(), 150);

// 5) Render row with row class + position split link + numeric idx data source
function renderRow(r) {
  const idx = fmtInt(r.index) ?? safe(r.index);
  const idxVal = fmtInt(r.index);
  const idxCell = idxVal != null
    ? `<span class="mono" data-order="${idxVal}">${idxVal}</span>`
    : `<span class="mono">${safe(r.index)}</span>`;

  // Seen
  const firstSeen = r["time:firstseen"] || "";
  const lastSeen = r["time:lastseen"] || "";
  const atMindist = r["time:time_at_mindist"] || "";
  const closestTs = atMindist || lastSeen || firstSeen;
  const whenHtml = (closestTs || firstSeen || lastSeen)
    ? formatSeen(firstSeen, closestTs, lastSeen, r.complete)
    : "";

  const icao = safe(r.icao);
  const tail = safe(r.tail);
  const cs = safe(r.callsign);
  const typ = safe(r.type);
  const owner = safe(r.owner);
  const tailFaaLink = safe(r["link:faa"]);
  const ownerFaLink = safe(r["link:fa"]);
  const tailHtml = tail ? (isHttp(tailFaaLink) ? `<a href="${tailFaaLink}" target="_blank" rel="noopener">${tail}</a>` : tail) : "";
  const ownerHtml = owner ? (isHttp(ownerFaLink) ? `<a href="${ownerFaLink}" target="_blank" rel="noopener">${owner}</a>` : owner) : "";
  const ownerLine = ownerHtml ? `<span class="muted">${ownerHtml}</span>` : "";
  // If a type is present, render it as a Skybrary link (lowercased). Encode the path component to be safe.
  const typHtml = typ ? (() => {
    try {
      const typePath = encodeURIComponent(String(typ).toLowerCase());
      const url = `https://skybrary.aero/aircraft/${typePath}`;
      return `<a href="${url}" target="_blank" rel="noopener">${typ}</a>`;
    } catch (e) { return typ; }
  })() : '';
  const route = safe(r.route);
  // Show route after callsign in the same Aircraft cell, unless it's 'n/a'
  const routeHtml = (route && route.toLowerCase() !== 'n/a') ? `<span class="route-chip">${route}</span>` : '';
  // Right after the callsign, add the ICAO value when both exist
  const csIcaoLine = cs
    ? `${cs}${icao ? ' · ' + icao : ''}`
    : `${icao}`;
  const photoLabel = csIcaoLine || tail || icao || 'Aircraft photo';
  const photoCaption = escapeHtml(photoLabel);
  const photoSourceUrl = r["image:link"];
  const flagIcon = renderFlagIconForIcao(icao);
  const aircraftLines = [];
  aircraftLines.push(`<div class="mono aircraft-main">${flagIcon ? flagIcon : ''}<span>${csIcaoLine}</span></div>`);
  if (routeHtml) aircraftLines.push(`<div>${routeHtml}</div>`);
  const detailParts = [];
  if (tailHtml) detailParts.push(tailHtml);
  if (typHtml || typ) detailParts.push(typHtml || typ);
  if (ownerLine) detailParts.push(ownerLine);
  if (detailParts.length) aircraftLines.push(`<div>${detailParts.join(' · ')}</div>`);
  const aircraft = aircraftLines.join('').trim();

  // Position: coords link only; angle outside link; add N/E
  const lat = r.lat, lon = r.lon;
  const coordText = formatLatLon(lat, lon);
  const map = safe(r["link:map"]);
  const angleDegRaw = Number(r["angle:value"]);
  const angleDegInt = Number.isFinite(angleDegRaw) ? Math.round(angleDegRaw) : null;
  const angleName = r["angle:name"] ? ` (${safe(r["angle:name"])})` : "";
  const angleStr = angleDegInt != null ? `${angleDegInt}°${angleName}` : "";
  const angleImg = (() => {
    const a = angleAssetName(angleDegRaw, document.documentElement.classList.contains('dark'));
    return a ? `<img class="angle-img" alt="" src="${cfg.mediaBase}${a}">` : "";
  })();
  const coordsHtml = coordText
    ? (map ? `<a href="${map}" target="_blank" rel="noopener">${coordText}</a>` : coordText)
    : "";
  // Put coords on first line and angle (text + image) plus distance on the second line within the same cell.
  const angleCombined = [angleStr, angleImg].filter(Boolean).join('');
  // Distance + unit appended inline with the angle, separated by a middot
  const distNum = Number(r["distance:value"]);
  const distUnit = safe(r["distance:unit"] || "");
  let distStr = "";
  if (Number.isFinite(distNum)) {
    const formatted = distNum < 10 ? distNum.toFixed(1) : Math.round(distNum).toString();
    distStr = `${formatted} ${distUnit}`.trim();
  } else if (r["distance:value"]) {
    distStr = `${safe(r["distance:value"]) } ${distUnit}`.trim();
  }
  const angleLine = [angleCombined, distStr].filter(Boolean).join(' · ');
  const positionInner = [
    coordsHtml ? `<div>${coordsHtml}</div>` : '',
    angleLine ? `<div>${angleLine}</div>` : ''
  ].filter(Boolean).join('');
  const position = positionInner ? `<div class="position-cell">${positionInner}</div>` : "";

  const altRaw = Number(r["altitude:value"]);
  const altVal = Number.isFinite(altRaw) ? `${safe(r["altitude:value"])} ${safe(r["altitude:unit"] || "ft")}` : "";
  const spdNum = fmtInt(r["groundspeed:value"]);
  const spdUnit = safe(r["groundspeed:unit"] || "kt");
  const spdVal = spdNum != null ? `${spdNum} ${spdUnit}` : "";
  // Choose numeric ordering priority: altitude (feet) if present, else groundspeed (kt), else 0
  const numericOrder = Number.isFinite(altRaw) ? altRaw : (spdNum != null ? spdNum : 0);
  // Combine altitude and speed into a single cell (altitude on first line, speed on second if present)
  const altspdInner = [altVal ? `<div class="mono">${altVal}</div>` : '', spdVal ? `<div class="mono">${spdVal}</div>` : ''].filter(Boolean).join('');
  // Include separate numeric attributes for altitude and speed to allow
  // independent numeric sorting when a user clicks Alt or Spd in the header.
  const altAttr = Number.isFinite(altRaw) ? altRaw : '';
  const spdAttr = spdNum != null ? spdNum : '';
  const altspd = `<div data-order-alt="${altAttr}" data-order-spd="${spdAttr}">${altspdInner}</div>`;

  const trackDegRaw = Number(r["track:value"]);
  const trackDegInt = Number.isFinite(trackDegRaw) ? Math.round(trackDegRaw) : null;
  const trackName = r["track:name"] ? ` (${safe(r["track:name"])})` : "";
  const trkStr = trackDegInt != null ? `${trackDegInt}°${trackName}` : "";
  const trkImg = (() => {
    const a = angleAssetName(trackDegRaw, document.documentElement.classList.contains('dark'));
    return a ? `<img class="angle-img" alt="" src="${cfg.mediaBase}${a}">` : "";
  })();
  const trk = trkStr ? `${trkStr}${trkImg}` : "";

  const thumbUrl = r["image:thumblink"];
  const imageFile = safe(r["image:file"]);
  const imageBasename = (() => {
    if (!imageFile) return '';
    const parts = String(imageFile).split('/').filter(Boolean);
    return parts.length ? parts[parts.length - 1] : '';
  })();
  const fullImageLocal = imageBasename ? `./imgcache/${imageBasename}` : '';
  let thumbEl = "";
  if (isHttp(thumbUrl)) {
    const thumbAttr = thumbUrl.replace(/"/g,'&quot;');
    const viewerSrc = (fullImageLocal || thumbUrl).replace(/"/g,'&quot;');
    const sourceAttr = photoSourceUrl ? photoSourceUrl.replace(/"/g,'&quot;') : '';
    thumbEl = `<img class="thumb thumb-photo" loading="lazy" data-src="${thumbAttr}" data-fullsrc="${viewerSrc}" data-caption="${photoCaption}" data-sourcelink="${sourceAttr}" alt="${photoCaption}" tabindex="0" role="button" aria-label="View larger aircraft photo">`;
  } else {
    // Fallback: show silhouette based on aircraft type code (e.g., PC21.bmp) if available
    const typCodeRaw = safe(r.type || '');
    const code = typCodeRaw.replace(/[^A-Za-z0-9]/g,'').toUpperCase();
    if (code) {
      const base = cfg.silhouetteDir || (cfg.mediaBase + 'silhouettes/');
      const silSrc = `${base}${code}.bmp`;
      // Hide the image if the silhouette is not found
  thumbEl = `<img class="thumb thumb-sil" loading="lazy" data-src="${silSrc.replace(/"/g,'&quot;')}" alt="silhouette ${code}" onerror="this.style.display='none'">`;
    }
  }

  const spectro = safe(r["spectro:link"]);
  const noise = safe(r["noisegraph:link"]);
  const mp3 = safe(r["mp3:link"]);

  const notifyLinks = [];
  const discordLink = r["discord:link"];
  const bskyLink = r["bsky:link"];
  const mastodonLink = r["mastodon:link"];
  const telegramLink = r["telegram:link"];
  const mqttFlag = r["mqtt:notified"];
  const discordNotified = truthy(r["discord:notified"]);
  const bskyNotified = truthy(r["bsky:notified"]);
  const mastodonNotified = truthy(r["mastodon:notified"]);
  const telegramNotified = truthy(r["telegram:notified"]);
  const mqttNotified = truthy(mqttFlag);

  if (discordLink) {
    // discord:link may be a comma-separated list of URLs; render each as its own anchor
    const links = String(discordLink)
      .split(',')
      .map(s => s.trim())
      .filter(Boolean);
    const multi = links.length > 1;
    for (let i = 0; i < links.length; i++) {
      const lnk = links[i];
      const label = multi ? `Discord (${i+1})` : 'Discord';
      notifyLinks.push(notifierLink(lnk, label, iconDiscord()));
    }
  } else if (discordNotified) {
    notifyLinks.push(`<span class="chip muted has-tooltip" title="There's no link associated with this notification">${iconDiscord()}<span class="label">Discord</span></span>`);
  }

  if (bskyLink) notifyLinks.push(notifierLink(bskyLink, 'Bluesky', iconBluesky()));
  else if (bskyNotified) notifyLinks.push(`<span class="chip muted has-tooltip" title="There's no link associated with this notification">${iconBluesky()}<span class="label">Bluesky</span></span>`);

  if (mastodonLink) notifyLinks.push(notifierLink(mastodonLink, 'Mastodon', iconMastodon()));
  else if (mastodonNotified) notifyLinks.push(`<span class="chip muted has-tooltip" title="There's no link associated with this notification">${iconMastodon()}<span class="label">Mastodon</span></span>`);

  if (telegramLink) notifyLinks.push(notifierLink(telegramLink, 'Telegram', iconTelegram()));
  else if (telegramNotified) notifyLinks.push(`<span class="chip muted has-tooltip" title="There's no link associated with this notification">${iconTelegram()}<span class="label">Telegram</span></span>`);

  if (mqttNotified) notifyLinks.push(`<span class="chip muted has-tooltip" title="There's no link associated with this notification">${iconMQTT()}<span class="label">MQTT</span></span>`);

  // Sound column: show a small chip with peak/loud info, and separate small clickable badges for noisegraph and mp3 if present.
  let sound = "";
  const parts = [];
  if (hasSound(r)) {
  const peak = r["sound:peak"] ? `Peak ${safe(r["sound:peak"]) } dbFS` : "";
  const loud = r["sound:loudness"] ? `Loud ${safe(r["sound:loudness"]) } dB` : "";
  const dot = r["sound:color"] ? `<span class="dot" style="background:${safe(r["sound:color"]) }"></span>` : "";
    const inner = `<span class="chip">${dot}${[peak, loud].filter(Boolean).join(' · ')}</span>`;
    parts.push(inner);
  }
  // Build Sound column in two lines: first Peak/Loudness, then the chip links below
  let measurementChip = '';
  if (hasSound(r)) {
    const peak = r["sound:peak"] ? `Peak ${safe(r["sound:peak"]) } dbFS` : "";
    const loud = r["sound:loudness"] ? `Loud ${safe(r["sound:loudness"]) } dB` : "";
    const dot = r["sound:color"] ? `<span class="dot" style="background:${safe(r["sound:color"]) }"></span>` : "";
    measurementChip = `<span class="chip">${dot}${[peak, loud].filter(Boolean).join(' · ')}</span>`;
  }
  const linkChips = [];
  // Noisegraph badge
  if (noise) {
    const nUrl = normalizeNoiseLink(noise).replace(/"/g,'&quot;');
    const nBadge = iconNoise();
    linkChips.push(`<a class="chip" href="${nUrl}" target="_blank" rel="noopener" title="Show noisegraph" aria-label="Show noisegraph">${nBadge}</a>`);
  }
  // Spectrogram badge (distinct icon)
  if (spectro) {
    const sUrl = normalizeNoiseLink(spectro).replace(/"/g,'&quot;');
    const sBadge = iconSpectro();
    linkChips.push(`<a class="chip" href="${sUrl}" target="_blank" rel="noopener" title="Show spectrogram" aria-label="Show spectrogram">${sBadge}</a>`);
  }
  // MP3 badge
  if (mp3) {
    const mUrl = normalizeNoiseLink(mp3).replace(/"/g,'&quot;');
    const mBadge = iconMp3();
    linkChips.push(`<a class="chip" href="${mUrl}" target="_blank" rel="noopener" title="Play audio" aria-label="Play audio">${mBadge}</a>`);
  }
  if (measurementChip && linkChips.length) sound = `<div>${measurementChip}</div><div>${linkChips.join(' ')}</div>`;
  else if (measurementChip) sound = measurementChip;
  else if (linkChips.length) sound = `<div>${linkChips.join(' ')}</div>`;

  const planeAlertCell = renderPlaneAlertCell(r);

  const squawkVal = safe(r["squawk:value"]);
  const squawkDesc = r["squawk:description"] ? ` <span class="muted">(${safe(r["squawk:description"])})</span>` : "";
  const isEmerg = squawkVal === "7500" || squawkVal === "7600" || squawkVal === "7700";
  const squawk = squawkVal ? `<span class="${isEmerg ? 'danger' : ''} mono">${squawkVal}</span>${squawkDesc}` : "";

  return {
    row: [
    `${idxCell}`,
    `${thumbEl}`,
    `${whenHtml}`,
  `${aircraft}`,
  `${position}`,
  `${altspd}`,
    `${trk}`,
    `${squawk}`,
    `${sound}`,
    `${planeAlertCell}`,
    `${notifyLinks.join(' ')}`
  ],
    incomplete: String(r.complete) !== 'true'
  };
}

function renderPlaneAlertCell(r){
  if (!r || typeof r !== 'object') return '';
  const pieces = [];
  ['db:tag1','db:tag2','db:tag3'].forEach(key => {
    const val = safe(r[key]).trim();
    if (val) pieces.push(`<span class="mono">${val}</span>`);
  });
  const linkVal = safe(r['db:link']).trim();
  if (linkVal) {
    const href = linkVal.replace(/"/g, '&quot;');
    const favicon = planeAlertFaviconUrl(linkVal);
    const faviconImg = favicon ? `<img class="plane-alert-favicon" src="${favicon}" alt="">` : '';
    pieces.push(`<a href="${href}" target="_blank" rel="noopener">${faviconImg}<span>Link</span></a>`);
  }
  return pieces.length ? `<div class="plane-alert-cell">${pieces.join(' · ')}</div>` : '';
}


// 6) Prepend newest-first during streaming and apply row class
function addOrUpdateRow(r){
  const rendered = renderRow(r);
  const idxVal = fmtInt(r.index);
  if (Number.isFinite(idxVal) && rowByIndex.has(idxVal)) {
    try {
      const apiRow = rowByIndex.get(idxVal);
      apiRow.data(rendered.row);
      return { api: apiRow, created: false, idx: idxVal };
    } catch (e) {
      console.warn('row update failed, falling back to add', e);
      rowByIndex.delete(idxVal);
    }
  }

  const apiRow = table.row.add(rendered.row);
  try {
    const first = rendered.row && rendered.row[0] ? String(rendered.row[0]) : '';
    const m = first.match(/data-order="(-?\d+)"/);
    const id = Number.isFinite(idxVal) ? idxVal : (m ? Number(m[1]) : null);
    if (Number.isFinite(id)) {
      const node = apiRow.node();
      if (node) node.dataset.idx = id;
      rowByIndex.set(id, apiRow);
      return { api: apiRow, created: true, idx: id };
    }
  } catch (e) { /* ignore */ }
  return { api: apiRow, created: true, idx: idxVal };
}

  // 4) Position: link only coords, add cardinal directions; angle outside link
  function formatLatLon(lat, lon){
    const latNum = Number(lat);
    const lonNum = Number(lon);
    if (!Number.isFinite(latNum) || !Number.isFinite(lonNum)) return "";
    const latDir = latNum >= 0 ? 'N' : 'S';
    const lonDir = lonNum >= 0 ? 'E' : 'W';
    const latStr = `${toFixed4(Math.abs(latNum))}&deg; ${latDir}`;
    const lonStr = `${toFixed4(Math.abs(lonNum))}&deg; ${lonDir}`;
    return `${latStr}, ${lonStr}`;
  }

  function applyMediaPrefixes(row){
    if (!cfg.noisePrefix || !row || typeof row !== 'object') return;
    const keys = ['noisegraph:link','spectro:link','mp3:link'];
    const prefix = cfg.noisePrefix;
    keys.forEach(key => {
      const val = row[key];
      if (val && !val.startsWith('http') && !val.startsWith(prefix)) {
        row[key] = prefix + val;
      }
    });
  }

  if (!table) buildHeader();
  restartDataPipelines();


  async function startStreamReader(generation){
    if (!cfg.enableStream) return;
    stopStreamReader();
    const controller = new AbortController();
    streamAbortController = controller;
    const modeForRun = dataMode;
    try {
      const resp = await fetch(buildStreamUrl(modeForRun), { cache: 'no-store', signal: controller.signal });
      if (!resp.ok || !resp.body) { if (prog) prog.textContent = 'Stream failed'; return; }

      const reader = resp.body.getReader();
      const dec = new TextDecoder();
      let buf = '';
      let added = 0;
      let seenHeader = false;
      let streamGlobals = {};

      function setStreamGlobals(g) {
        streamGlobals = {};
        if (!g || typeof g !== 'object') return;
        streamGlobals.HASNOISE = truthy(g.HASNOISE || g.hasOwnProperty('HASNOISE') && g.HASNOISE);
        streamGlobals.HASIMAGES = truthy(g.HASIMAGES || g.hasOwnProperty('HASIMAGES') && g.HASIMAGES);
        streamGlobals.HASROUTE = truthy(g.HASROUTE || g.hasOwnProperty('HASROUTE') && g.HASROUTE);
        streamGlobals.LASTUPDATE = Number(g.LASTUPDATE) || 0;
        streamGlobals.maxindex = Number(g.maxindex) || 0;
        for (const k of Object.keys(g)) if (!(k in streamGlobals)) streamGlobals[k] = g[k];
        setHasNoiseAvailability(streamGlobals.HASNOISE);
        updateStationInfoFromGlobals(streamGlobals);
      }

      while (true) {
        if (generation !== modeGeneration || controller.signal.aborted) return;
        const {value, done} = await reader.read();
        if (done) break;
        buf += dec.decode(value, {stream:true});
        let nl;
        while ((nl = buf.indexOf('\n')) >= 0) {
          if (generation !== modeGeneration || controller.signal.aborted) return;
          const line = buf.slice(0, nl); buf = buf.slice(nl+1);
          if (!line.trim()) continue;
          let obj;
          try { obj = JSON.parse(line); } catch(e){ console.error('Bad JSON:', e, line); continue; }
          if (obj && obj.__globals) {
            setStreamGlobals(obj.__globals || {});
            if (streamGlobals.LASTUPDATE && Number.isFinite(streamGlobals.LASTUPDATE) && streamGlobals.LASTUPDATE > 0) {
              const dt = new Date(streamGlobals.LASTUPDATE * 1000);
              const hh = String(dt.getHours()).padStart(2,'0');
              const mm = String(dt.getMinutes()).padStart(2,'0');
              lastUpdateEl.textContent = `Last update: ${hh}:${mm}`;
            }
            if (streamGlobals.maxindex && streamGlobals.maxindex > 0 && prog) {
              prog.textContent = `Loaded 0 / ${streamGlobals.maxindex}`;
            }
            continue;
          }

          if (!seenHeader && obj && obj.__columns) {
            seenHeader = true;
            continue;
          }
          if (obj && typeof obj === 'object' && Object.keys(obj).length === 1 && obj.error) {
            if (prog) prog.textContent = `Error: ${obj.error}`;
            continue;
          }
          const payload = (obj && typeof obj === 'object')
            ? Object.assign({}, streamGlobals, obj)
            : obj;

          applyMediaPrefixes(payload);

          const norm = normalizeRow(payload);
          if (!norm || !norm.icao || String(norm.icao).trim() === '') {
            continue;
          }
          const res = addOrUpdateRow(norm);
          if (res.created && Number.isFinite(Number(res.idx))) {
            pendingNewIndices.add(Number(res.idx));
            updateNewUpdatesBanner();
          }
          added++;
          if (added % 10 === 0) {
            if (generation !== modeGeneration || controller.signal.aborted) return;
            redrawTable(false);
            if (prog) prog.textContent = `Loaded ${rowCount()}…`;
          }
        }
      }

      if (buf.trim()) {
        try {
          const last = JSON.parse(buf);
          if (generation !== modeGeneration || controller.signal.aborted) return;
          const res = addOrUpdateRow(last);
          if (res.created && Number.isFinite(Number(res.idx))) {
            pendingNewIndices.add(Number(res.idx));
            updateNewUpdatesBanner();
          }
        } catch(e) { /* ignore parse */ }
      }
      if (generation !== modeGeneration || controller.signal.aborted) return;
      redrawTable(true);
      if (prog && !prog.textContent.startsWith('Error')) prog.textContent = `Done. Rows: ${rowCount()}`;
    } catch (e) {
      if (controller.signal.aborted || generation !== modeGeneration) return;
      console.error('stream error', e);
      if (prog) prog.textContent = 'Stream error';
    } finally {
      if (streamAbortController === controller) streamAbortController = null;
    }
  }

  function stopStreamReader(){
    if (streamAbortController) {
      try { streamAbortController.abort(); } catch (e) { /* ignore */ }
      streamAbortController = null;
    }
  }

// -------- Polling snapshot every 60s and apply incremental updates --------
// Uses same endpoint (`./cgi/pfstream.sh`) which emits NDJSON (globals, schema, rows)
// and updates existing rows (by index) or appends new rows. Does a single draw at end.
async function pollAndMerge(modeForRun, generation) {
  try {
    if (generation !== modeGeneration) return;
    const resp = await fetch(buildStreamUrl(modeForRun), { cache: 'no-store' });
    if (!resp.ok) { console.warn('poll: fetch failed', resp.status); return; }
    if (generation !== modeGeneration) return;
    const txt = await resp.text();
    if (generation !== modeGeneration) return;
    if (!txt) return;

    const lines = txt.split('\n');
    let localGlobals = {};
    let seenHeader = false;
  const toAdd = [];
  const toUpdate = [];
  // Track which numeric indices were present in the latest snapshot so we can purge missing rows
  const seenIndices = new Set();

    for (const line of lines) {
      if (!line.trim()) continue;
      let obj;
      try { obj = JSON.parse(line); } catch (e) { console.warn('poll: bad json', e, line); continue; }
      if (obj && obj.__globals) { localGlobals = obj.__globals || {};
        updateStationInfoFromGlobals(localGlobals);
        setHasNoiseAvailability(localGlobals.HASNOISE);
        if (localGlobals.LASTUPDATE && Number.isFinite(Number(localGlobals.LASTUPDATE)) && Number(localGlobals.LASTUPDATE) > 0) {
          const dt = new Date(Number(localGlobals.LASTUPDATE) * 1000);
          const hh = String(dt.getHours()).padStart(2,'0');
          const mm = String(dt.getMinutes()).padStart(2,'0');
          lastUpdateEl.textContent = `Last update: ${hh}:${mm}`;
        }
        continue; }
      if (!seenHeader && obj && obj.__columns) { seenHeader = true; continue; }
      if (!obj || typeof obj !== 'object') continue;

      const payload = Object.assign({}, localGlobals, obj);
      applyMediaPrefixes(payload);

  const norm = normalizeRow(payload);
  // Ignore records without an ICAO value
  if (!norm || !norm.icao || String(norm.icao).trim() === '') continue;
      const rendered = renderRow(norm);

      // Fast lookup: use rowByIndex map to find existing row by numeric index
      const numericIdx = Number(norm.index);
      if (Number.isFinite(numericIdx)) seenIndices.add(numericIdx);
      const foundApi = Number.isFinite(numericIdx) ? rowByIndex.get(numericIdx) : null;
      if (foundApi) {
        // Existing row: update and clear any missing counter
        toUpdate.push({ api: foundApi, row: rendered.row, idx: numericIdx });
        missingCounts.delete(numericIdx);
      } else {
        // New row: add and clear any missing counter (might have been previously missing)
        toAdd.push({ row: rendered.row, idx: numericIdx });
        missingCounts.delete(numericIdx);
      }
    }

    if (generation !== modeGeneration) return;

    // Apply updates
    for (const u of toUpdate) {
      try {
        // Prefer direct API update. Some API objects may be stale before a draw,
        // so if this fails, fall back to locating the row node by data-idx.
        u.api.data(u.row);
      } catch(e) {
        console.warn('poll: update failed via api, trying fallback', e, u && u.idx);
        try {
          if (Number.isFinite(u.idx)) {
            const tr = document.querySelector(`tr[data-idx="${u.idx}"]`);
            if (tr) table.row(tr).data(u.row);
            else console.warn('poll: fallback row not found for idx', u.idx);
          }
        } catch (ee) { console.warn('poll: fallback update failed', ee); }
      }
    }
    // Append new rows and register them in rowByIndex
    for (const item of toAdd) {
      const apiRow = table.row.add(item.row);
      // If we know the numeric index, register the newly added row in the map
      try {
        if (Number.isFinite(item.idx)) {
          const node = apiRow.node();
          if (node) node.dataset.idx = item.idx;
          rowByIndex.set(item.idx, apiRow);
          // mark as pending so banner/highlight will show
          pendingNewIndices.add(Number(item.idx));
        } else {
          // Fallback: attempt to parse from the first-cell HTML
          const first = item.row && item.row[0] ? String(item.row[0]) : '';
          const m = first.match(/data-order="(-?\d+)"/);
          if (m) {
            const id = Number(m[1]);
            const node = apiRow.node();
            if (node) node.dataset.idx = id;
            rowByIndex.set(id, apiRow);
            pendingNewIndices.add(Number(id));
          }
        }
      } catch (e) { /* ignore */ }
    }

    // After applying updates/adds, purge any rows not present in the snapshot.
    // Purge rows that have been absent for at least 2 consecutive polls
    let purged = 0;
    try {
      for (const [idx, apiRow] of rowByIndex.entries()) {
        const nidx = Number(idx);
        if (seenIndices.has(nidx)) continue; // present in this snapshot

        // Increment miss counter
  if (generation !== modeGeneration) return;

        const prev = missingCounts.get(nidx) || 0;
        const now = prev + 1;
        missingCounts.set(nidx, now);

        // If absent for 2 or more polls, purge it
        if (now >= 2) {
          try {
            const node = apiRow.node();
            if (node) table.row(node).remove();
          } catch (e) { /* ignore per-row remove errors */ }
          rowByIndex.delete(nidx);
          missingCounts.delete(nidx);
          purged++;
        }
      }
    } catch (e) { console.warn('poll: purge failed', e); }

    // Single redraw to refresh display (preserve paging)
    if (toUpdate.length || toAdd.length || purged) {
      redrawTable(false);
      // After the draw, ensure any newly-created row nodes are registered in rowByIndex.
      try {
        table.rows().every(function(){
          const tr = this.node();
          if (!tr) return;
          // If the TR already has an idx, ensure the map contains it
          if (tr.dataset && tr.dataset.idx) {
            const id = Number(tr.dataset.idx);
            if (Number.isFinite(id) && !rowByIndex.has(id)) rowByIndex.set(id, table.row(tr));
            return;
          }
          // Otherwise try to parse the first-cell HTML for data-order and set dataset
          try {
            const d = this.data();
            const first = d && d[0] ? String(d[0]) : '';
            const m = first.match(/data-order="(-?\d+)"/);
            if (m) {
              const id = Number(m[1]);
              tr.dataset.idx = id;
              if (Number.isFinite(id)) rowByIndex.set(id, table.row(tr));
            }
          } catch (e) { /* ignore per-row */ }
        });
      } catch (e) { console.warn('poll: post-draw registration failed', e); }
  // If new rows were added during the poll, update the banner count.
  if (toAdd.length) updateNewUpdatesBanner();
  if (prog) prog.textContent = `Updated ${toUpdate.length} / Added ${toAdd.length} / Purged ${purged} — Rows: ${rowCount()}`;
    }
  } catch (e) {
    console.error('pollAndMerge error', e);
  }
}

  function stopPollingLoop(){
    if (pollIntervalHandle) {
      clearInterval(pollIntervalHandle);
      pollIntervalHandle = null;
    }
    nextPollAt = null;
    startCountdown();
  }

  function startPollingLoop(generation){
    if (!cfg.enablePoll) return;
    stopPollingLoop();
    const intervalMs = (cfg.pollIntervalSec || 60) * 1000;
    const runOnce = async ()=>{
      const modeForRun = dataMode;
      await pollAndMerge(modeForRun, generation);
      if (generation === modeGeneration) scheduleNextPoll(cfg.pollIntervalSec || 60);
    };
    runOnce().catch(e => console.error('poll loop run', e));
    pollIntervalHandle = setInterval(()=> runOnce().catch(e => console.error('poll loop run', e)), intervalMs);
  }

  function restartDataPipelines(){
    modeGeneration++;
    resetTableState();
    stopStreamReader();
    stopPollingLoop();
    if (cfg.enableStream) startStreamReader(modeGeneration);
    if (cfg.enablePoll) startPollingLoop(modeGeneration);
  }

// New-updates banner: when user clicks, jump to first page and show new rows
if (newUpdatesBtn) {
  newUpdatesBtn.addEventListener('click', ()=>{
    try {
      if (table) {
        table.page('first').draw(false);
        // After jumping, highlight pending rows
        highlightPendingNewRows();
      }
      newUpdatesBtn.style.display = 'none';
    } catch (e) { console.error('newUpdates click', e); }
  });
}

</script>

<script>
// Lazy-load images using IntersectionObserver (thumb and spectro)
function lazyLoadImagesIn(container){
  try {
    const root = container || document;
    const imgs = root.querySelectorAll('img[data-src]');
    if (!imgs || imgs.length === 0) return;
    if ('IntersectionObserver' in window) {
      const io = new IntersectionObserver((entries, obs)=>{
        for (const e of entries) {
          if (e.isIntersecting) {
            const img = e.target;
            const src = img.getAttribute('data-src');
            if (src) { img.src = src; img.removeAttribute('data-src'); }
            obs.unobserve(img);
          }
        }
      }, { root: null, rootMargin: '100px', threshold: 0.01 });
      imgs.forEach(img => io.observe(img));
    } else {
      imgs.forEach(img => { const src = img.getAttribute('data-src'); if (src) { img.src = src; img.removeAttribute('data-src'); } });
    }
  } catch (e) { /* ignore */ }
}

// Observe DataTables draws to (re)apply lazy loading
document.addEventListener('DOMContentLoaded', ()=>{
  try { lazyLoadImagesIn(document); } catch(e){}
  try { if (window.table) table.on('draw', ()=> lazyLoadImagesIn(document)); } catch(e){}
});
</script>
</body></html>
